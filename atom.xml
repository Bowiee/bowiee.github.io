<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不务正业的博客</title>
  
  <subtitle>学习的时光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bowiee.github.io/"/>
  <updated>2019-07-25T13:37:10.569Z</updated>
  <id>http://bowiee.github.io/</id>
  
  <author>
    <name>Bowiee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>example</title>
    <link href="http://bowiee.github.io/2019/07/25/example/"/>
    <id>http://bowiee.github.io/2019/07/25/example/</id>
    <published>2019-07-25T13:09:09.000Z</published>
    <updated>2019-07-25T13:37:10.569Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/07/25/example/1.png" alt="asddf"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/07/25/example/1.png&quot; alt=&quot;asddf&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>论文阅读：Dynamic Bike Reposition: A Spatio-Temporal Reinforcement Learning Approach</title>
    <link href="http://bowiee.github.io/2019/07/25/Dynamic-Bike-Reposition/"/>
    <id>http://bowiee.github.io/2019/07/25/Dynamic-Bike-Reposition/</id>
    <published>2019-07-25T11:11:00.000Z</published>
    <updated>2019-07-25T14:39:57.887Z</updated>
    
    <content type="html"><![CDATA[<p>论文标题：通过强化学习，实现自行车的动态调配<br><a href="https://dl.acm.org/citation.cfm?doid=3219819.3220110" target="_blank" rel="noopener">原文链接</a><br>参考资料：<br><a href="https://morvanzhou.github.io/" target="_blank" rel="noopener">莫凡的个人网站</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">论文题目：Dynamic Bike Reposition: A Spatio-Temporal Reinforcement Learning Approach</span><br><span class="line">发表时间：KDD 2018，August 19-23,2018</span><br><span class="line">论文作者：Yenxin Li   Yu Zheng   Qiang Yang</span><br></pre></td></tr></table></figure><p>论文作者详细介绍：<br><img src="https://upload-images.jianshu.io/upload_images/18539550-11fde41fe82de8ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Yenxin Li(未找到照片)"><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Yenxin Lin是香港科技大学的学生<br><img src="https://upload-images.jianshu.io/upload_images/18539550-71def92f06cd4e06.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" Qiang Yang"><br>&emsp;&emsp;&emsp;&emsp;杨教授现任香港科技大学计算机科学与工程系讲师。他的研究兴趣包括机器学习，人工智能和数据挖掘。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-3724f6241eb2f42c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Qiang Yang"><br>&emsp;&emsp;&emsp;&emsp;京东金融副总裁，首席数据科学家。 主要任务是利用大数据和人工智能技术解决交通和城市规划等城市挑战。<br><strong>1.Introduction</strong><br>这篇文章所讲的自行车的动态调配，并不是指的共享单车，而是下图所示的比较传统的自行车站，这主要是因为课题研究的时候，共享单车还没有火，并且论文所使用的数据是英国的数据，那边没有共享单车。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-f0721f66db027496.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公用自行车"><br>在整个地区的自行车站点里，总是会有一些站点缺少自行车，而有些站点的自行车过多，一般需要通过运输的方式将自行车进行调配，这篇论文解决的就是如何调配，也就是应该从哪一个站点运输多少辆自行车到其他某个站点去。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/01.png" alt="调度"><br><strong>2.Our approach</strong><br>一个市的面积是很大的，我们不可能在整个市的所有自行车站点之间进行自行车的调配，这是不必要的，同时也会浪费大量的人力、物力、财力，所以我们应该减少，调配自行车的范围，比如现在有7个自行车站点，我们不会在这7个站点之间进行自行车的调配。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/02.png" alt="自行车站点"><br>在这7个站点，我们会根据规则对其进行划分，规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.两个站点之间的距离要接近，相隔太远是无法划分到一个区域里面的。</span><br><span class="line">2.有着相同的行车轨迹，比如小区周围的自行车站，都会到一些办公的区域去，这就是共同的行车轨迹。</span><br></pre></td></tr></table></figure><p>最后这7个站点，可以根据这些规则划分为两个区域（这里只是举个例子）：<br><img src="/2019/07/25/Dynamic-Bike-Reposition/03.png" alt="区域1-某居住区"><br><img src="/2019/07/25/Dynamic-Bike-Reposition/04.png" alt="区域2-某工作区"><br>因为这些区域地理位置相近，且行车轨迹也大致相同，现在我们将分好的区域作为单位去考虑自行车调配的问题，但是即便如此，从城市的角度来看，我们也不需要在所有不同的区域之间进行自行车的调配。比如在下面的上海地图中，上面的圆圈表示的就是区域，人们一般不会从松江骑个车到静安区，所以考虑整个城市所有区域的调配是不必要的。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/06.png" alt="上海市"><br>所以，我们可以将区域分成不同的组，只在组之间进行调配，这样可以大大的节省下资源。显然，现在的问题，就是应该如何去分组保证调配的合理。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/06.png" alt="区域分组"><br>区域分组的过程分成了三个步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Step 1:根据这两个区域之间的通勤记录进行连接，通行频率高于给定阈值的就进行连接。</span><br><span class="line">Step 2:社区发现，一个区域连接的不同区域越多，说明越有可能形成一个社区，只与几个相连，那我们就将这个连接给去掉。</span><br><span class="line">Step 3:将那些剩下的结点，根据已有的聚类算法，合并到某个组去。</span><br></pre></td></tr></table></figure><p><img src="/2019/07/25/Dynamic-Bike-Reposition/20.png" alt="将区域进行分组"><br>现在已经完成了区域分组，我们只会在组内，进行自行车的调配，组与组之间的调配，我们是忽略不计的。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/21.png" alt="完成了区域分组"><br>到现在，要解决的问题就是，如何在组内进行自行车的调配，也就是找到调配自行车的策略，这篇论文使用的就是强化学习的方法。所以下面简要的介绍一下，强化学习是什么：<br><img src="/2019/07/25/Dynamic-Bike-Reposition/08.png" alt="强化学习"><br>强化学习就是像图中的小朋友一样，一开始什么都不懂，然后经过不断的试错，掌握了知识，找到了正确的方法。<br>强化学习就像是一个人，第一次见到火，他不知道这是什么。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/22.jpg" alt="强化学习"><br>但是他感觉到了温暖，所以他觉得火是好的，并且想要更靠近火。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/23.jpg" alt="强化学习"><br>在触碰了之后，被火给烫到了，他学会了不能离的太近，也不能去触碰火。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/24.jpg" alt="强化学习"><br>在经过这一学习过程后，他学会了，要适当的保持距离，不能触碰。<br>强化学习就如下图所示，我们做出某些行为，得到反馈，我们对环境进行观察，最后不断学习的过程。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/40.png" alt="强化学习过程"><br>强化学习的分类方法有很多，这里的分类就是按是否基于模型来分类的，下面进行详细的介绍。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/10.png" alt="不基于模型的强化学习"><br>不基于模型的强化学习，就是只能通过现有的观察来得出结论，进行学习。比如这里有一个机器人，它想知道在地球上扔一个原子弹会发生什么，它这样做了，然后把自己给炸死了。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/09.png" alt="基于模型的强化学习"><br>基于模型的强化学习，现在这个机器人也要做同样的事情，但是它是基于模型的，所以它拥有了想象力，它可以再做出一个地球的模型，然后在这个假的地球上做实验，得出结论。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/11.png" alt="不基于模型的强化学习"><br>Model-Free RL只能够做一步，看看反应，然后再做，最后完成学习的过程，它是没有想象力的。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/12.png" alt="基于模型的强化学习"><br>Model-Based RL就是可以想象出做了之后的事情，然后可以从中选择一个去执行。<br>下面是用神经网络实现的强化学习过程，输入现在的状态和动作，神经网络会根据反馈给这个动作打一个分。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/13.png" alt="强化学习"><br>回到论文中来，我们会利用强化学习，来完成自行车调配问题，输入现在各自行车站点的信息，比如数量，和运输车的信息，再还要输入可能会做的许多的调配行动，选择神经网络里面分数最高的一个去执行。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/14.png" alt="神经网络学习"><br>为了让神经网络能判断的更准确，还加入了一个模拟器，用来模拟自行车的归还需求，以及租界需求，当然是在一定的时间里面进行的模拟。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/16.png" alt="模拟器"><br>在这个过程里，根据神经网络的判断进行自行车的运输，之后会得到反馈，这些记录都存放在样本池里面，用来供神经网络学习，使其判断的更准确。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/15.png" alt="学习过程"><br>自行车的动态调配过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Cluster : 在图中的Region Clusters部分，也就是上文所讲的分组过程，我们只会在组内进行自行车的调配。</span><br><span class="line">2.Current state : 将现在的状态输入，也就是天气、自行车数量、运输车位置。</span><br><span class="line">3.network ： 通过神经网络来确定我们所要执行的调配策略。</span><br><span class="line">4.Reposition : 执行这个调配自行车的动作。</span><br></pre></td></tr></table></figure><p><img src="/2019/07/25/Dynamic-Bike-Reposition/17.png" alt="自行车的动态调配过程"><br><strong>3.Experiment</strong><br>图中的数字表示的是顾客减少量，也就是没有骑到自行车的人，从图中我们可以看到，使用STRL也就是本文所介绍的方法，顾客的损失量是最少的，也即是效果最好。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/41.png" alt="Customer loss in the morning rush hours "></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;论文标题：通过强化学习，实现自行车的动态调配&lt;br&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?doid=3219819.3220110&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;参考资料：
      
    
    </summary>
    
      <category term="论文阅读" scheme="http://bowiee.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="论文" scheme="http://bowiee.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>eclipse导入java项目后，出现错误提示的解决办法</title>
    <link href="http://bowiee.github.io/2019/07/25/eclipse%E5%AF%BC%E5%85%A5java%E9%A1%B9%E7%9B%AE/"/>
    <id>http://bowiee.github.io/2019/07/25/eclipse导入java项目/</id>
    <published>2019-07-25T11:07:57.000Z</published>
    <updated>2019-07-25T11:09:16.653Z</updated>
    
    <content type="html"><![CDATA[<p>在将一个java项目导入后，可能会出现许多的错误提示，例如：<br><img src="https://upload-images.jianshu.io/upload_images/18539550-b3e67fd3a13380a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误提示"></p><p>这些错误可能是由于jdk版本不同所导致的，那应该如何解决呢？<br>1.右键项目，点击Build Path中的Configuer  Build Path<br><img src="https://upload-images.jianshu.io/upload_images/18539550-d9f0561b6dd4a1b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="找到Configuer  Build Path "><br>2.在Libraries中将那个有红叉的JRE的移除，再点击Add Library,添加新的<br><img src="https://upload-images.jianshu.io/upload_images/18539550-97e9e3246a8875ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移除JRE并添加"><br>3.在出现的弹窗里选择JRE System Library，一直点下去就好了。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-23c8996d0de3ca5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击next"><br><img src="https://upload-images.jianshu.io/upload_images/18539550-2e352016389cfad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击Finish"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在将一个java项目导入后，可能会出现许多的错误提示，例如：&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/18539550-b3e67fd3a13380a2.png?imageMogr2/auto-
      
    
    </summary>
    
      <category term="踩过的坑" scheme="http://bowiee.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="java" scheme="http://bowiee.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>安装Mysql时端口号3306被占用的处理方法</title>
    <link href="http://bowiee.github.io/2019/07/25/%E5%AE%89%E8%A3%85Mysql%E6%97%B6%E7%AB%AF%E5%8F%A3%E5%8F%B73306%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>http://bowiee.github.io/2019/07/25/安装Mysql时端口号3306被占用的处理方法/</id>
    <published>2019-07-25T11:06:22.000Z</published>
    <updated>2019-07-25T14:08:52.518Z</updated>
    
    <content type="html"><![CDATA[<p>有些情况下端口号3306会被占用，例如我们卸载了Mysql重新安装时就会出现这种情况。<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/01.png" alt="端口号被占用"><br>解决方案如下：<br>1.打开命令窗口（windows+R,输入cmd）<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/02.png" alt="打开命令窗口"><br>2.输入命令  netstat -ano（查看端口的使用情况）<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/03.png" alt="端口号使用情况"><br>同时我们需要记住，后面的PID数字，也就是这里的4748<br>3.打开任务管理器<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/04.png" alt="打开任务管理器"><br>4.点击查看详细信息<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/05.png" alt="查看详细信息"><br>在这里可以点击PID，它会按照从小到大的顺序排列，之后找到4478，右键关闭即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些情况下端口号3306会被占用，例如我们卸载了Mysql重新安装时就会出现这种情况。&lt;br&gt;&lt;img src=&quot;/2019/07/25/安装Mysql时端口号3306被占用的处理方法/01.png&quot; alt=&quot;端口号被占用&quot;&gt;&lt;br&gt;解决方案如下：&lt;br&gt;1.打开命令窗口
      
    
    </summary>
    
      <category term="踩过的坑" scheme="http://bowiee.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="mysql" scheme="http://bowiee.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JDBC的连接设置问题</title>
    <link href="http://bowiee.github.io/2019/07/25/jdbc%E7%9A%84%E8%BF%9E%E6%8E%A5/"/>
    <id>http://bowiee.github.io/2019/07/25/jdbc的连接/</id>
    <published>2019-07-25T11:04:10.000Z</published>
    <updated>2019-07-25T11:05:53.063Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql版本：community-5.7.17.0</span><br></pre></td></tr></table></figure><p>在连接时，需要书写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/web01?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure><p>上面的useUnicode=true&amp;characterEncoding=UTF-8都是用来完成编码的设置，而useSSL=true建立SSLl连接。如果未明确设置，MySQL 5.5.45+, 5.6.26+ and 5.7.6+版本默认要求建立SSL连接。 若未设置，则会出现下列警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WARN: Establishing SSL connection without server’s identity verification is not recommended. </span><br><span class="line">According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. </span><br><span class="line">For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. </span><br><span class="line">You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</span><br></pre></td></tr></table></figure><p>在jdbc的配置中如果myaql是6.0及以上的，会有所不同，需要按照以下设置驱动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>否则就会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loading class &apos;com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is &apos;com.mysql.cj.jdbc.Driver&apos;. </span><br><span class="line">The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</span><br></pre></td></tr></table></figure><p>同时mysql 6.0以上还需要设置时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://&lt;u&gt;localhost&lt;/u&gt;:3306/ssm_spring?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=UTC</span><br></pre></td></tr></table></figure><p>不过值得注意的是UTC代表的是全球标准时间，我们使用的是北京时区，领先UTC八个小时。所以我们可以将时区设置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="踩过的坑" scheme="http://bowiee.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="mysql" scheme="http://bowiee.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>错误提示：The reference to entity &quot;useSSL&quot; must end with the &#39;;&#39; delimiter.</title>
    <link href="http://bowiee.github.io/2019/07/25/XML%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
    <id>http://bowiee.github.io/2019/07/25/XML中的特殊字符/</id>
    <published>2019-07-25T11:00:46.000Z</published>
    <updated>2019-07-25T11:02:26.939Z</updated>
    
    <content type="html"><![CDATA[<p>###XML中的特殊字符<br>XML中总共有5个特殊字符，如果配置文件中要写这些特殊字符的话，就需要进行特别处理。</p><p>使用XML转义序列表示这些特殊的字符，这5个特殊字符所对应XML转义序列为：</p><blockquote><p>&amp; 替换为 &amp;amp;<br>&lt; 替换为 &amp;lt;<br>&gt; 替换为 &amp;gt;<br>&quot;  替换为 &amp;quot;<br>&#39;  替换为 &amp;apos;<br>（后面的 ; 替换字符中的一部分，也要一起写入的）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###XML中的特殊字符&lt;br&gt;XML中总共有5个特殊字符，如果配置文件中要写这些特殊字符的话，就需要进行特别处理。&lt;/p&gt;
&lt;p&gt;使用XML转义序列表示这些特殊的字符，这5个特殊字符所对应XML转义序列为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;amp; 替换为 &amp;a
      
    
    </summary>
    
      <category term="知识总结" scheme="http://bowiee.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://bowiee.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读: Streaming Graph Partitioning: An Experimental Study</title>
    <link href="http://bowiee.github.io/2019/07/25/Streaming%20Graph%20Partitioning/"/>
    <id>http://bowiee.github.io/2019/07/25/Streaming Graph Partitioning/</id>
    <published>2019-07-25T10:45:57.000Z</published>
    <updated>2019-07-25T10:56:44.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="论文阅读：Streaming-Graph-Partitioning-An-Experimental-Study"><a href="#论文阅读：Streaming-Graph-Partitioning-An-Experimental-Study" class="headerlink" title="论文阅读：Streaming Graph Partitioning: An Experimental Study"></a>论文阅读：Streaming Graph Partitioning: An Experimental Study</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">论文标题：Streaming Graph Partitioning: An Experimental Study</span><br><span class="line">发表：PVLDB, 11(11): 1590-1603, 2018</span><br><span class="line">作者：Zainab Abbas、Vasiliki Kalavri、Paris Carbone、Vladimir Vlassov</span><br></pre></td></tr></table></figure><p><a href="href=" http: www.vldb.org pvldb vol11 p1590-abbas.pdf"">原文连接</a><br>作者详细介绍：</p><p><img src="https://upload-images.jianshu.io/upload_images/18539550-623d458e522f60fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Zainab Abbas"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名：Zainab Abbas</span><br><span class="line">院校：皇家理工学院（瑞典）的研究生</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/18539550-78e88c2970323936.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vasiliki Kalavri"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名：Vasiliki Kalavri</span><br><span class="line">院校：皇家理工学院（瑞典）的博士</span><br><span class="line">研究方向：分布式数据处理和大规模图形分析</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/18539550-53298069f23ce839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paris Carbone"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名：Paris Carbone</span><br><span class="line">院校：皇家理工学院（瑞典）的博士</span><br><span class="line">研究方向：分布式系统、数据管理</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/18539550-e2b32959038de489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vladimir Vlassov"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名：Vladimir Vlassov</span><br><span class="line">院校：皇家理工学院（瑞典）的教授</span><br><span class="line">研究方向：数据密集型计算和流处理; 云资源管理; 基于云的服务和应用程序</span><br></pre></td></tr></table></figure><p><strong>1.前言</strong><br>现实世界数据量十分巨大，而这些数据大多都是用图来表示的（如下图所示），所以处理图的数据，对现实世界是至关重要的。而在计算中，图的分布式计算是重要的，分布式计算，必然带来图的分区。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-555dda571738bb64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="社交信息"></p><p><img src="https://upload-images.jianshu.io/upload_images/18539550-c6068c96068fc560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="神经信息"></p><p>在进行分区之前，我们来看看完整的处理图数据的过程<br><img src="https://upload-images.jianshu.io/upload_images/18539550-a8d97c8ed65295a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图数据处理流程"></p><p>大致上分为三步， 首先将图数据加载，然年后进行分区，最后是计算过程。在分区之前，通用图分区方法扫描完整图以获得结构特征。 然而，对低延迟，连续图形分析的新兴需求导致了在线分区方法的发展。 在线方法将边或顶点作为流摄取，而不是提前完整的加载。</p><p><strong>在图处理过程中一般的图分区方法</strong><br><img src="https://upload-images.jianshu.io/upload_images/18539550-47ecf8fa7dd5c098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一般的图分区方法"></p><p>分为两种，也就是Edge-cut和Vertex-cut，Edge-cut的意思就是切边，对结点进行分区，让边跨越各个分区，这种方法不需要构造其他结点。Vertex-cut就是切结点，对边进行分区，会判断每条边应属于哪一个区，显然不同的边有可能连接着同一个结点，并且这些边也分在不同的区，所以结点要进行复制，跟着边走，边在哪里，结点就在哪里。如图所示，复制了z结点，以及d结点。</p><p><strong>流图分区</strong><br>所以对于这篇论文所讲的流图分区来说，主要也是这两种方法。<br>流图分区中的流，分为两种，一种是边流，一种是结点流。边流就是不断有边数据流入，然后对其判断边属于哪个分区。结点流就是以结点的形式流入。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-f611a6e4d0989e81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流图分区"></p><p><strong>2.Streaming Graph Partitioning</strong><br>本文所讲的流图分区，大致分为三类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Vertex Partitioning Methods（结点流，对结点进行分区）</span><br><span class="line">2. Edge Partitioning Methods （边流，对边进行分区）</span><br><span class="line">3. Model-Agnostic (其他方法，混合各种方法使用)</span><br></pre></td></tr></table></figure><ul><li><strong>Vertex Partitioning Methods(按结点的分区方法)</strong><br>按结点分区的大致过程如下图所示，左边表示原始图形，共有6个结点（0，1，2，3，4，5），上面的表格表示图的输入顺序，（0：1）表示输入的是0号节点，同时记录和它相邻的结点1号。这里输入的顺序是随机的。结点的分区共有三个，分区数量是提前确定的。最后生成右下角的分区图形。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-42c15d5dca72cdbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vertex Partitioning Methods"></li></ul><p>这个分区方法所使用的原理就是<strong>Linear Deterministic Greedy (LDG)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线性确定性贪婪分区（LDG）尝试将相邻顶点放置到同一分区，以减少边缘切割。在满足容量约束的同时，将一个顶点分配给包含大多数邻居的分区。</span><br></pre></td></tr></table></figure><p>如下图所示，在某个分区中存在1号和4号结点，我们现在要判断2号节点所在分区，根据LDG我们会选择2号结点邻居最多的分区，所以最后会将1，2，4三个结点放在同一个分区。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-04a118a5c09fe5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Linear Deterministic Greedy (LDG)"></p><p>不过这样会存在问题，就是所有的结点可能都会在同一个区里。（比如说放置了第一个结点，第二个是它的邻居会放在一起，之后也是如此）<br><img src="https://upload-images.jianshu.io/upload_images/18539550-d77d05b70f6824de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="聚集到一个分区"></p><p>为了解决这个问题，我们会给每个分区里的结点数量进行限制，其中C就是最大的容量，根据结点个数以及分区的个数计算出来。所以这种方法需要知道图的全局信息，比如结点数量。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-69f20328cfe1d5ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="容量的限制"></p><ul><li><strong>Edge Partitioning Methods(按边的分区方法)</strong><br>这种方法就是判断每条边，应该属于哪一个分区里面，过程如下图。<br>上面的表格就是输入流，（3，2）表示从结点3指向结点2的边。按照箭头顺序输入，这里是随机输入。黄色结点是复制的结点。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-33f38e0563bd7351.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Edge Partitioning Methods"></li></ul><p>显然对于按边分区的方法来说，复制结点越多，就代表着这种分区是不好的，所以我们在进行按边分区的时候，应该尽可能的减少结点的复制，于是解决的办法就是首先复制那些度高的结点，比如说图中红色的结点，这样能减少总体的复制次数。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-de73fe6e3c5f8a27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HDRF"><br>那具体的过程是怎样的呢？首先我们输入边，并且边上的结点都不属于任何分区，如图所示，这里有三个分区，用三种颜射表示。在这种情况下，我们会将这条边放在负载最低的分区里，也就是边最少的分区里。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-5f8b5a631eac9aa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结点不属于任何分区"><br>如果输入的边其中一个结点属于某个分区，另一个不属于任何分区的话，就将这条边放置在结点属于的那个分区里面，也就是下图中蓝色的区。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-38e62595f94e86ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="其中一个结点属于某个区"><br>两个结点，其中一个属于多个分区，另一个也属于某个分区，并且有交集，那这条边就会放在有交集的区里，也就是下图橙色的区。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-a9bf4cd14ae7bb5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结点所在区有交集"><br>如果这两个存在属于不同的分区，却没有交集，根据HDRF也就是先复制度高的，所以我们会复制下图中左边的结点。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-1579aa4328b51c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结点所在区无交集"><br>结果如下<br><img src="https://upload-images.jianshu.io/upload_images/18539550-dcb01f8a20839292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="根据HDRF分区结果"></p><ul><li><strong>Model-Agnostic (其他方法，混合各种方法使用)</strong><br>其他方法里面也有许多种，这里介绍一下哈希的方法。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-d6ca648cbb6d93cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基于哈希的混合划分"><br>对于低度数的点，我们会对本身结点进行哈希，比如这里的4号结点，我们会对4进行哈希运算，然后将4号结点，以及所有的入边都分配到这个块中。 对于高度数的顶点，我们会对源节点进行哈希，比如这里的1号结点，我们会对2号和5号结点进行哈希，然后按照2号和5号的结果，分配到块中。 这种方法需要知道图的全局信息，还要知道机器数，比如这里的机器数是三，那么求哈希值的时候，就是除以3求余数。 这种方法是边分区和结点分区一起使用的，混合方法。<br>高度顶点和低度顶点的区别是用给定的阈值来区分的，并且首先要确定好分区数量。</li><li><em>3.Experiment*</em><br>这个实验中，我们设置的分区数是4<br>分区性能就是指每秒钟的吞吐量，意思就是指每秒钟把多少结点或者边，分配到某一个区里面去。<br>我们的结果表明Hash分区在吞吐量方面优于所有其他评估方法。 然而，性能的差异并不显着。 在这两个实验中，Hash显示的吞吐量最多比第二个最佳分区方法高2倍，并且随着图的增大，这个差异也在减小。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-990bf9b20303d538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Partitioning Performance"></li></ul><p>这里将Twitter和Friendster的分区数设置为16，剩下两个较小的分区数设置为4.<br>A good partitioning method is not only fast but also pro-duces high-quality partitions（不仅要分的快，还要分的好）所以要评判分区的质量。对于按结点的分区来说，我们用edge-cut指标来评判分区的质量，edge-cut越多，说明分区质量就不太高，因为通信成本大大增加了。入就是这个指标对于按边分区的方法来说，我们用结点的复制次数来评判分区的质量，如果复制的次数太多，说明分区的质量不太好。图b就是这个指标。在最后，我们还要考虑负载均衡的问题，也就是分布的较为平均的意思，不能所有的结点或者边，都在一个区里面。哈希的负载均衡是最好的，因为是完全随机的分配的。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-3411a504b82cb4bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Partitioning Quality"></p><p>算法的性能也和输入的结点或者边的顺序有关，比如这里是使用随机输入，或者DFS输入，都对算法性能有着很大的影响。<br><img src="https://upload-images.jianshu.io/upload_images/18539550-847a887a3f7298ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sensitivity to Order"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;论文阅读：Streaming-Graph-Partitioning-An-Experimental-Study&quot;&gt;&lt;a href=&quot;#论文阅读：Streaming-Graph-Partitioning-An-Experimental-Study&quot; class=&quot;h
      
    
    </summary>
    
      <category term="论文阅读" scheme="http://bowiee.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="论文" scheme="http://bowiee.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>MySQL WorkBench 如何运行sql文件，将其变为数据库</title>
    <link href="http://bowiee.github.io/2019/07/25/MySQL%20WorkBench/"/>
    <id>http://bowiee.github.io/2019/07/25/MySQL WorkBench/</id>
    <published>2019-07-25T08:33:08.000Z</published>
    <updated>2019-07-25T08:37:17.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-WorkBench-如何运行sql文件，将其变为数据库"><a href="#MySQL-WorkBench-如何运行sql文件，将其变为数据库" class="headerlink" title="MySQL WorkBench 如何运行sql文件，将其变为数据库"></a>MySQL WorkBench 如何运行sql文件，将其变为数据库</h2><blockquote><p>环境：win10<br>软件：mysql community 5.7.17.0<br>操作时间：2019/7/1</p></blockquote><p>在sql文件里，已经有了生成数据库的语句，这样执行才会生成数据库。<br><strong>下面是操作步骤</strong>：<br><strong>1.打开WorkBench进入操作界面</strong><br><img src="https://upload-images.jianshu.io/upload_images/18539550-b6a4a6543eb4def6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进入界面"></p><p>会看到如下图：<br><img src="https://upload-images.jianshu.io/upload_images/18539550-5b94f44186fe030d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建数据库界面"></p><p><strong>2.运行sql文件</strong><br>找到运行sql脚本处：<br><img src="https://upload-images.jianshu.io/upload_images/18539550-b9a90e9df04a2079.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行sql文件"></p><p>选取sql文件：<br><img src="https://upload-images.jianshu.io/upload_images/18539550-c8d39a32172c586c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选取sql文件"></p><p><strong>3.生成数据库</strong><br>最后生成的数据库会显示在图中圈出来部分：<br><img src="https://upload-images.jianshu.io/upload_images/18539550-02082f3d57d3e2eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-WorkBench-如何运行sql文件，将其变为数据库&quot;&gt;&lt;a href=&quot;#MySQL-WorkBench-如何运行sql文件，将其变为数据库&quot; class=&quot;headerlink&quot; title=&quot;MySQL WorkBench 如何运行sql文件，
      
    
    </summary>
    
      <category term="踩过的坑" scheme="http://bowiee.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="mysql" scheme="http://bowiee.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java JDBC编程流程步骤</title>
    <link href="http://bowiee.github.io/2019/07/25/JDBC/"/>
    <id>http://bowiee.github.io/2019/07/25/JDBC/</id>
    <published>2019-07-25T07:07:48.000Z</published>
    <updated>2019-07-25T07:11:56.233Z</updated>
    
    <content type="html"><![CDATA[<p>JDBC：Java Data Base ConnectionJDBC是用于运行sql语句并从数据库中获取新新的java API.JDBC是用来（让我们的程序）通过网络来操作数据库的，作用非常重要；JDBC技术也是Java核心技术之中的一个。是使用JDBC驱动程序訪问数据库的首选方式<br>JDBC总共分为6步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、注冊驱动 </span><br><span class="line">2、建立连接　</span><br><span class="line">3、创建运行SQL的语句</span><br><span class="line">4、运行语句　　</span><br><span class="line">5、处理运行结果</span><br><span class="line">6、释放资源</span><br></pre></td></tr></table></figure><p>第一步：注册驱动<br>推荐使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(“com.mysql.jdbc.Driver”);</span><br></pre></td></tr></table></figure><p>如果mysql版本高，需要写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(“com.mysql.cj.jdbc.Driver”);</span><br></pre></td></tr></table></figure><p>第二步：建立连接<br>通过Connection建立连接，Connection是一个接口类。其功能是与数据库进行连接。<br>使用方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　Connection con =DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure><p>其中user，password就是数据库的用户名和密码，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/web01</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure><p>第三步：创建运行对象<br>由Statement运行sql语句，不过我们一般使用派生出的PreparedStatement。<br>PreparedStatement能够对SQL语句进行预编译，提高了安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement  ps=connection.prepareStatement( &quot;update user set id=? where username=?”);</span><br></pre></td></tr></table></figure><p>sql中由?表示占位符，再通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps.setObject(1, object);</span><br></pre></td></tr></table></figure><p>来设置值，1就表示第一个问号，也就是id ，Object就是我们要设置的值。<br>第四步：运行sql语句<br>reparedStatement 提供两个经常使用的方法来运行SQL语句。　　<br>executeQuery(Stringsql),该方法用于运行实现查询功能的sql语句。返回类型为ResultSet（结果集）。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet  rs =st.executeQuery(sql);</span><br></pre></td></tr></table></figure><p>executeUpdate(Stringsql),该方法用于运行实现增、删、改功能的sql语句，返回类型为int，即受影响的行数。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int flag = st.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>第五步：处理运行结果</p><p>ResultSet对象　　ResultSet对象负责保存Statement运行后所产生的查询结果。<br>例如我们可以打印出里面的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(rs.getInt(&quot;id&quot;)+&quot;,&quot;+rs.getString(&quot;username&quot;)+&quot;,&quot;+rs.getString(&quot;password&quot;));</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><p>rs就是ResultSet。<br>第六步：<br>数据库资源不关闭，其占用的内存不会被释放，所以要进行关闭。要按照和打开相反的顺序，先打开的后关闭，后打开的先关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">打开</span><br><span class="line">Connection con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">PreparedStatement pstmt = con.prepareStatement(sql);</span><br><span class="line"> ResultSet rs = pstmt.executeQuery();</span><br><span class="line">关闭</span><br><span class="line">rs.close();</span><br><span class="line">pstmt.close();</span><br><span class="line">con.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JDBC：Java Data Base ConnectionJDBC是用于运行sql语句并从数据库中获取新新的java API.JDBC是用来（让我们的程序）通过网络来操作数据库的，作用非常重要；JDBC技术也是Java核心技术之中的一个。是使用JDBC驱动程序訪问数据库的
      
    
    </summary>
    
      <category term="知识总结" scheme="http://bowiee.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://bowiee.github.io/tags/java/"/>
    
      <category term="mysql" scheme="http://bowiee.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
