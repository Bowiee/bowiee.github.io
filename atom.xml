<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不务正业的博客</title>
  
  <subtitle>学习的时光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bowiee.github.io/"/>
  <updated>2019-07-30T14:04:47.849Z</updated>
  <id>http://bowiee.github.io/</id>
  
  <author>
    <name>Bowiee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论：后缀树</title>
    <link href="http://bowiee.github.io/2019/07/30/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    <id>http://bowiee.github.io/2019/07/30/后缀树/</id>
    <published>2019-07-30T13:51:53.000Z</published>
    <updated>2019-07-30T14:04:47.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法导论：后缀树"><a href="#算法导论：后缀树" class="headerlink" title="算法导论：后缀树"></a>算法导论：后缀树</h3><p>参考资料：<br><a href="http://brenden.github.io/ukkonen-animation/" target="_blank" rel="noopener">在线构造后缀树</a><br><a href="https://www.jianshu.com/p/d35acf651d98" target="_blank" rel="noopener">Ukkonen’s Algorithm构造后缀树实录</a><br><a href="https://www.cnblogs.com/xubenben/p/3484988.html" target="_blank" rel="noopener">后缀树系列</a><br>在阅读本文之前，需要了解字典树，请看<a href="https://www.jianshu.com/p/617d8fd5dde6" target="_blank" rel="noopener">字典树</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义：后缀树是一棵压缩字典树，其次，后缀树中存储的关键词为所有的后缀。</span><br></pre></td></tr></table></figure><p>下面将对后缀树的构建以及优化做出详细的介绍。</p><h4 id="后缀树的构建"><a href="#后缀树的构建" class="headerlink" title="后缀树的构建"></a>后缀树的构建</h4><h5 id="列出字符串所有后缀"><a href="#列出字符串所有后缀" class="headerlink" title="列出字符串所有后缀"></a>列出字符串所有后缀</h5><p>以字符串S=MISSISSIPPI$为例<br>S的所有后缀如下：<br>S[0…11]= MISSISSIPPI$  &emsp; &emsp; &emsp; &emsp; &emsp; 字符串本身，起始位置0<br>S[1…11]=  &ensp; ISSISSIPPI$  &emsp; &emsp; &emsp; &emsp; &emsp;&emsp;   起始位置1<br>S[2…11]=  &emsp;SSISSIPPI$     &emsp; &emsp; &emsp; &emsp; &emsp;&emsp;  起始位置2<br>S[3…11]= &emsp;&ensp; SISSIPPI$        &emsp; &emsp; &emsp; &emsp; &emsp;&emsp; 起始位置3<br>&emsp;&ensp; .<br>&emsp;&ensp; .<br>S[10…11]=&emsp; &emsp; &emsp; &emsp;&ensp; I$    &emsp; &emsp; &emsp; &emsp; &emsp;&emsp;起始位置10<br>S[11…11]=&emsp; &emsp; &emsp; &emsp;&emsp;$    &emsp; &emsp; &emsp; &emsp; &emsp;&emsp; 终结符<br>字符串最后的$是人为添加的，这样保证后缀的唯一性，不会出现横跨多个字符串的后缀。</p><h5 id="在平方时间类构造后缀树"><a href="#在平方时间类构造后缀树" class="headerlink" title="在平方时间类构造后缀树"></a>在平方时间类构造后缀树</h5><h6 id="采用构建字典树方式构建（方法一）"><a href="#采用构建字典树方式构建（方法一）" class="headerlink" title="采用构建字典树方式构建（方法一）"></a>采用构建字典树方式构建（方法一）</h6><p>（1）将上述字符串的所有后缀加入到字典树中，得到如下结构：<br><img src="/2019/07/30/后缀树/01.png" alt="后缀树的构造"><br>（2）将字典树中没有分支的路径压缩：<br><img src="/2019/07/30/后缀树/02.png" alt="后缀树的构造"><br>要遍历所有的结点时间复杂度为</p><h6 id="多边同步插入构建（方法二）"><a href="#多边同步插入构建（方法二）" class="headerlink" title="多边同步插入构建（方法二）"></a>多边同步插入构建（方法二）</h6><p>这种方法的含义就是给定一个字符串，直接构造后缀树，不需要先构造字典树。<br>在讲这个方法之前，需要先了解一些概念：<br><img src="/2019/07/30/后缀树/03.png" alt="基本概念"><br>在这里后缀树中的结点分为两大类，显示结点，隐士结点。显示节点就是那些分支处或者叶子节点，隐式节点是被压缩的那些节点。还有用来辅助构造后缀树的尾部链表，构造时，会沿着尾部链表进行更新。<br><img src="/2019/07/30/后缀树/04.png" alt="节点"><br>沿着尾部链表更新时的规则：<br>我们通过例子来讲述这个更新规则，现在我们有字符串{ababcd$}，内部节点，叶子节点，隐式节点分别用不同的样式来表示。<br><img src="/2019/07/30/后缀树/05.png" alt="构建后缀树"><br>首先第一个字符a开始，构建如图所示，尾部链表从a的叶子节点指向根节点。现在我们插入下一个字符b，插入字符时说沿着链表进行更新的，这里先更新叶子节点，再更新根节点这个内部节点。<br><img src="/2019/07/30/后缀树/06.png" alt="规则1"><br>这个是更新时的规则1，更新叶子节点时直接插入字符即可。<br><img src="/2019/07/30/后缀树/07.png" alt="规则2"><br>这个是更新时的规则2，在更新到内部节点时的规则。<br>根据这两条规则，我们可以对字符串{ababcd$}的b字符进行更新。<br><img src="/2019/07/30/后缀树/08.png" alt="构建后缀树"><br>这里更新叶子节点时，将b直接放置在a后面即可，然后沿着链表更新根节点，因为紧邻着根节点的字符只有a，不存在b，所以构造出一个新的节点b出来。这样做的主要目的，就是希望表示出，字符的所有后缀，现在的后缀有两个ab和b，这两个字符都必须出现在后缀树上。尾部链表会指向新出现的节点，最后指向根节点。<br>下面我们沿着链表插入a，此时存在两个叶子节点，一个内部节点。<br><img src="/2019/07/30/后缀树/09.png" alt="构建后缀树"><br>沿着链表更新，首先更新最左边的节点，所以直接将字符a写后面即可。然后我们更新到右边的叶子节点，按照规则1也是直接写在后面。最后更新到根节点，紧靠着根节点的字符分别时左边的a和右边的b，根据规则2，我们不在构建新的节点，只是将左边a字符的节点做一个标记，因为现在的三个后缀是aba,ba,a，要在后缀树中全部体现出来。<br>现在插入字符b<br><img src="/2019/07/30/后缀树/10.png" alt="构建后缀树"><br>在沿着链表更新时，叶子节点以及内部节点按照规则即可，但是会遇到隐式节点，现在会有规则3<br><img src="/2019/07/30/后缀树/11.png" alt="规则3"><br>这个是更新时的规则3，在按照规则的前提下，不断进行更新。<br><img src="/2019/07/30/后缀树/12.png" alt="构建后缀树"><br>构建完成后如下图所示，这种方法每一次都要从头开始遍历尾部链表<br><img src="/2019/07/30/后缀树/13.png" alt="完成构建"><br>        后缀树与字典树的不同在于，它的边不再只代表单个字符，而是通过一对整数 [from, to] 来表示。其中 from 和 to 所指向的是字符串在文本中的位置，这样每个边可以表示任意的长度，<br><img src="/2019/07/30/后缀树/14.png" alt="后缀树"><br>以上就完成了后缀树的构建过程。<br>在使用方法二时，需要遵守的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">规则1：遇到叶子节点时只需往叶子所在的边上面的字符串后面插入字符就好了，不用改变树的结构；</span><br><span class="line">规则2：遇到内部节点的时候，先看看插入的字符是否出现在显式节点后紧跟的字符</span><br><span class="line">      集合中,如果插入的字符出现在集合中，那么什么也不要做（是指不用改变构），</span><br><span class="line">      因为已经存在了；如果没有出现，在显式节点后面增加一个叶子，边上标注为这个字符。</span><br><span class="line">规则3：遇到隐式节点时，先看看隐式节点后面的字符是不是当前将要插入的字符，</span><br><span class="line">      如果有则不用管了，没有则需要将当前隐式节点变为显式节点，再增加新叶子。</span><br></pre></td></tr></table></figure><h4 id="优化后缀树的构建"><a href="#优化后缀树的构建" class="headerlink" title="优化后缀树的构建"></a>优化后缀树的构建</h4><p>是在方法二的基础上进行的优化，下面将哟用具体的例子进行讲解，给出的字符串为abcabxabcd$。<br><img src="/2019/07/30/后缀树/15.png" alt="优化后方法"><br>首先构建字符a<br><img src="/2019/07/30/后缀树/16.png" alt="优化后方法"><br>然后，依照之前的方法插入字符b,c。当我们插入下一个字符a的时候，会发现在后缀树中，存在字符a了。所以在这时，我们不能简单的插入。<br><img src="/2019/07/30/后缀树/17.png" alt="优化后方法"><br>我们在按规则插入之后，要在字符a后做一个标记，就像之前讲的隐式结点，表示出有由a开始的后缀，a之后的字符就可以在这里操作。<br>为了记录这些信息，我们需要引入一些概念：<br>1、活动点（active point)<br>    是一个三元组(活动结点,活动边, 活动长度)<br>2、剩余后缀数（remainder）<br>    还没有在后缀树中体现的后缀<br>&emsp;&emsp;那对于上图，活动点是多少呢？答案是（0，a，1）0表示额就是根节点，在这个结点上进行活动。a表示的是会在由根节点周围a开始的那条边上进行相关操作，1表示的是在一位字符后操作，也就是a后，如果是2呢那就是在b后操作。<br>&emsp;&emsp;此时还没有体现在后追树上的后缀数是1.也就是后缀a，因为我们并不能找到a这个后缀，我们只是在a后做了标记，表示接下来会有由a开始的标记。<br><img src="/2019/07/30/后缀树/18.png" alt="优化后方法"><br>插入字符b和上面的a类似。此时的剩余后缀有b,ab两个，活动长度也变为了2。当插入下一个字符x时，x并不在后缀树中，显然，我们应该做一些别的操作了。<br>此时，还没有体现在后缀树中的后缀有，{abx,bx,x}，此时我们要插入后缀abx<br><img src="/2019/07/30/后缀树/19.png" alt="优化后方法"><br>后缀abx出现在了后缀树上，还没有体现的后缀是bx,x。我们会发现图中的活动边变为了b，活动长度也减少了，这样是为了让剩下的后缀更好的插入。<br><img src="/2019/07/30/后缀树/20.png" alt="规则1"><br>在向根节点插入时，需要遵循规则1。<br>现在还剩下的后缀时bx,x依次插入。<br><img src="/2019/07/30/后缀树/21.png" alt="优化后方法"><br>此时活动点变为了（0（根节点），none(无活动边)，0(无长度)）,剩余的后缀是x。<br>我们会发现图中多了一条=由4指向6的索引。这个就是另一条规则。<br><img src="/2019/07/30/后缀树/22.png" alt="规则2"><br>这里的后缀连接类似于之前讲过的尾部链表，主要目的是为了节省插入时间，比如我们在插入ab开始的某个后缀后（例如abz），我们还需要插入bz，那就可以直接通过这个后缀连接插入b。<br><img src="/2019/07/30/后缀树/23.png" alt="优化后方法"><br>在插入x后如上图所示。<br><img src="/2019/07/30/后缀树/24.png" alt="优化后方法"><br>后面插入a,b,c因为这些字符都已经存在于后缀树里了，所以只需要做记录不需要操作，当我们插入到d时，这是一个新的字符，所以要处理所有的剩余后缀了，每当遇到新的字符，才会开始处理剩余后缀。<br>此时的记录信息为：<br>活动点(4,c,1)<br>剩余后缀为abcd、bcd、cd、d。此时先处理后缀abcd，我们在记录处按照规则插入d。<br><img src="/2019/07/30/后缀树/25.png" alt="优化后方法"><br>当我们处理完后缀abcd后，活动点变为了（6，c，1），活动结点直接从4变为了6，这个就是根据规则3来完成的。<br><img src="/2019/07/30/后缀树/26.png" alt="规则3"><br><img src="/2019/07/30/后缀树/27.png" alt="优化后方法"><br>在优化后方法中，需要遵守的三个规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">规则1：当向根节点插入时遵循：</span><br><span class="line">      活动点保持为 root； </span><br><span class="line">      活动边被设置为即将被插入的新后缀的首字符；</span><br><span class="line">      活动长度减 1。</span><br><span class="line">规则2：如果我们分裂一条边并且插入一个新的节点，并且，如果该新节点不是当前</span><br><span class="line">      步骤中创建的第一个节点，则将先前插入的节点与该新节点通过一个特殊的指针 </span><br><span class="line">      连接，称为后缀连接。后缀连接通过一条虚线来表示。</span><br><span class="line">规则3：当从活动点不为根的节点分裂边时，我们沿着后缀连接的方向寻找节点，如</span><br><span class="line">      果存在一个节点，则设置该节点为活动点；如果不存在，则设置活动点为根节点。活动边和活动长度保持不变。</span><br></pre></td></tr></table></figure><p>在根据规则处理完所有的字符后，得到如图所示的后缀树，因为在整个过程中，只遍历了一遍字符串，且没有进行多余的结点操作，只是记录了一些信息，所以这个方法的时间复杂度是O(n)，可以在线性时间内完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法导论：后缀树&quot;&gt;&lt;a href=&quot;#算法导论：后缀树&quot; class=&quot;headerlink&quot; title=&quot;算法导论：后缀树&quot;&gt;&lt;/a&gt;算法导论：后缀树&lt;/h3&gt;&lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;http://brenden.github.io/ukk
      
    
    </summary>
    
      <category term="算法导论" scheme="http://bowiee.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://bowiee.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法导论：字典树</title>
    <link href="http://bowiee.github.io/2019/07/29/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>http://bowiee.github.io/2019/07/29/字典树/</id>
    <published>2019-07-29T07:54:11.000Z</published>
    <updated>2019-07-29T08:15:34.350Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法导论：字典树"><a href="#算法导论：字典树" class="headerlink" title="算法导论：字典树"></a>算法导论：字典树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义：Trie树，即字典树，又称单词查找树或键树。是一种用于快速检索的多叉树结构。</span><br><span class="line">     Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</span><br><span class="line">优点：最大限度地减少无谓的字符串比较。</span><br></pre></td></tr></table></figure><p>如果我们给定字符串集合为{b   abc   abd   bcd   abcd   efg   hii}，那么这个字符串的字典树为：<br><img src="/2019/07/29/字典树/01.png" alt="字典树"><br>对于一颗字典树来说，应该具有以下性质：<br><img src="/2019/07/29/字典树/02.png" alt="性质"><br>第二条性质中的到某个结点，就是指到红色结点。</p><h4 id="字典树的构建"><a href="#字典树的构建" class="headerlink" title="字典树的构建"></a>字典树的构建</h4><p><img src="/2019/07/29/字典树/03.png" alt="字典树的构建"><br>现在给出了，许多的字符串，我们从第一个字符串CAI开始构建。首先构建根节点，其次构建出CAI三个结点，<br><img src="/2019/07/29/字典树/04.png" alt="字典树构建"><br>现在构建字符串CAO因为CA已经存在，所以遍历到A，发现O结点并不存在，生成O结点。<br><img src="/2019/07/29/字典树/05.png" alt="字典树构建"><br>以此类推，最后生成的字典树，如上图所示。这个构建过程，每一次都相当于遍历了一个字符串的长度。<br>假如有n个字符串，那么它的时间复杂度就是，n乘上字符串的平均长度。<br><img src="/2019/07/29/字典树/06.png" alt="字典树的构建"><br>对于字典树，在空间上的花费为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空间花费：平均单词长度*结点长度*单词数</span><br></pre></td></tr></table></figure><h4 id="字典树的查询"><a href="#字典树的查询" class="headerlink" title="字典树的查询"></a>字典树的查询</h4><p><img src="/2019/07/29/字典树/07.png" alt="构建出字典树"><br>首先我们根据给出的单词，构建出了相应的字典树。<br><img src="/2019/07/29/字典树/08.png" alt="查询"><br>现在，我们要对inn这个单词进行查询，当然是从根节点先开始。<br><img src="/2019/07/29/字典树/09.png" alt="查询"><br>按照结点进行查询，最后可以找到inn这个字符串。那么它的时间复杂度就是这个字符串的长度O(len)。</p><h4 id="字典树的插入"><a href="#字典树的插入" class="headerlink" title="字典树的插入"></a>字典树的插入</h4><p><img src="/2019/07/29/字典树/10.png" alt="插入"><br>现在我们要插入新的字符串atm，那应该怎么做呢？<br><img src="/2019/07/29/字典树/11.png" alt="插入"><br>在走到t结点时，发现没有m结点，所以构造出m结点，并变为红色。</p><h4 id="字典树的删除"><a href="#字典树的删除" class="headerlink" title="字典树的删除"></a>字典树的删除</h4><p><img src="/2019/07/29/字典树/12.png" alt="删除"><br>现在我们要删除字典树中的ant字符串，当然是从根节点开始去做一个查询。<br><img src="/2019/07/29/字典树/13.png" alt="删除"><br>最后找到，结点t并且n结点也并没有其他分支，所以在删除时，会将n-&gt;t全部删除。<br><img src="/2019/07/29/字典树/14.png" alt="删除"><br>最后结果如图所示，时间复杂度也为O(len)。</p><h4 id="字典树的应用"><a href="#字典树的应用" class="headerlink" title="字典树的应用"></a>字典树的应用</h4><p><img src="/2019/07/29/字典树/15.png" alt="字典树的应用"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法导论：字典树&quot;&gt;&lt;a href=&quot;#算法导论：字典树&quot; class=&quot;headerlink&quot; title=&quot;算法导论：字典树&quot;&gt;&lt;/a&gt;算法导论：字典树&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="算法导论" scheme="http://bowiee.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://bowiee.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法导论：线性时间排序</title>
    <link href="http://bowiee.github.io/2019/07/28/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/"/>
    <id>http://bowiee.github.io/2019/07/28/线性时间排序/</id>
    <published>2019-07-28T12:45:07.000Z</published>
    <updated>2019-07-28T12:52:13.504Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h3><p>对于比较排序来说，在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们可以看到下图中的比较排序算法，在最坏情况下情况下，时间复杂度至少O(nlgn)。<br><img src="/2019/07/28/线性时间排序/01.png" alt="线性时间排序"><br>从图中我们可以较为清楚的看到各算法的时间复杂度，下面将证明对包含n个元素的输入序列来说，在最坏情况下，时间复杂度至少都是O(nlgn)。<br><img src="/2019/07/28/线性时间排序/02.png" alt="决策树"><br>比较排序可以被抽象为一颗决策树，那什么是决策树呢？比如上图所示，现在要出去相亲，首先判断年龄，如果大于30岁，那就直接不见了，小于30再考虑其他条件。之后，我们依次判断了，长相，收入，都满足了要求，于是决定去见上一面。<br>决策树是一颗完全二叉树（美式定义：要么有左右孩子、要么就没有孩子），非叶子结点都是一个逻辑判断，每个分支都是判断结果。</p><p><img src="/2019/07/28/线性时间排序/03.png" alt="决策树"><br>如上图所示，现在有三个数x,y,z。我们可以构建出如图所示的决策树，根结点是x和y比较，如果x≤y，再比较y和z的大小，如果x≥y，则比较x和z的大小。这里有三个数，并且是互异的，所以大小排列情况会有6种，如果有n个互译的数，那就是n!种。当x=6，y=8，z=5时，最后就会得到&lt;z,x,y&gt;这个结果，也就是&lt;5,6,8&gt;。<br><img src="/2019/07/28/线性时间排序/04.png" alt="决策树"><br>在最坏情况下，比较的次数，就是树的高度，2的h次方表示的是，总共的结点，肯定比叶子结点多，最后可以解出，h是大于等于O(nlgn)的。<br>介绍完了比较排序的时间复杂度，现在该介绍线性时间排序了。</p><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">问题描述：给定一个无序的序列，对序列进行排序，使之成为有序。</span><br><span class="line">基本思想：对于每一个输入元素x，确定小于x的元素个数，可以直接把x放到它在输出数组中的位置上,但是需要略微修改，因为一个位置不能存放两个元素</span><br></pre></td></tr></table></figure><p>算法的主要思想就是找到比元素x小的元素个数，元素x是待排序的元素。<br>那这个排序过程如何实现的呢？<br><img src="/2019/07/28/线性时间排序/05.png" alt="计数排序"><br>A数组就是我们的待排序序列{2，5，3，0，2，3，0，3}，C数组是用来记录比元素x小的元素个数，因为A中的数是0-5，所以B中的数组大小也是0~5，上标表示的就是A中的数。<br><img src="/2019/07/28/线性时间排序/06.png" alt="计数排序"><br>我们现在先记录，每个元素的个数是多少，现在指向2所以2的个数标记为1。<br><img src="/2019/07/28/线性时间排序/07.png" alt="计数排序"><br>指向5，所以5的个数变为1。<br><img src="/2019/07/28/线性时间排序/08.png" alt="计数排序"><br>在完成后，数组C中记录下了，各元素的个数。不过我们最终要的结果是记录下比元素x小的元素个数，所以这里面的数字还要进行简单的变换。<br><img src="/2019/07/28/线性时间排序/09.png" alt="计数排序"><br>现在我们将1中的0变更为2，这个数字表示的是小于等于1的数，也就是2，下面我们再记录小于等于2的数。<br><img src="/2019/07/28/线性时间排序/10.png" alt="计数排序"><br>小于等于2的个数，就是前面小于等于1的个数，再加上2自身的个数，结果为4。<br><img src="/2019/07/28/线性时间排序/11.png" alt="计数排序"><br>在完成更新后，所得如上图所示，每个数组中记录的数，就是小于等于自身的元素的个数。<br><img src="/2019/07/28/线性时间排序/12.png" alt="排序"><br>B数组就是我们最后的排序结果，对A数组从右向左进行遍历，这样是为了让排序是稳定的，排序的稳定是指，对于相同的数字，比如这里的2，在排序完成后，并不改变它们的相对次序。<br><img src="/2019/07/28/线性时间排序/13.png" alt="计数排序"><br>这里我们对3进行排序，去B数组查找，小于等于3的个数，找到为7就直接放在上标为7的数组中，并且将B中记录的数字减1。<br><img src="/2019/07/28/线性时间排序/14.png" alt="计数排序"><br>排序完成的结果，如图所示。<br><img src="/2019/07/28/线性时间排序/15.png" alt="计数排序时间复杂度"><br>因为要遍历两遍A数组，以及遍历一遍B数组，所以时间复杂度为O(n)+O(n)+O(k)=O(k+n)，当k=O(n)时T(n)=O(n)。</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本思想：基数排序的总体思路就是将待排序数据拆分成多个关键字进行排序，实质是多关键字排序。</span><br><span class="line">注意事项：选择低位优先排序，因为如果按照高位优先排序的，当排到次高位时，还需要返回看高位数字,相对来说比较麻烦。</span><br></pre></td></tr></table></figure><p><img src="/2019/07/28/线性时间排序/16.png" alt="基数排序"><br>例如，现在给出了7个数字，我们要对其进行排序，在这种位数很多的情况下，我们优先选择的就是基数排序。在基数排序时，优先对个位数进行排序，也就是最右边的那位数。<br><img src="/2019/07/28/线性时间排序/17.png" alt="基数排序"><br>要对个位数数字进行排序，那选择什么样的方法对其进行排序呢？只要是线性时间的排序，都是可行的，这里我们选择之前讲过的计数排序。<br><img src="/2019/07/28/线性时间排序/18.png" alt="基数排序"><br>再对十位数上面的数字进行排序。<br><img src="/2019/07/28/线性时间排序/19.png" alt="基数排序"><br>在完成排序后，可以得到上图的结果。<br>时间复杂度分析：<br>每个数字都是d位数，比如说这里都是三位数。每一次排序，都是计数排序，时间复杂度为O(n+k)，总共d次计数排序。所以时间复杂度为O(n+k)<em>d=O(d</em>(n+k))。</p><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>一般来说，只有在输入数据是给定的一个范围内，并且还是服从均匀分布的，才会使用桶排序。<br><img src="/2019/07/28/线性时间排序/20.png" alt="桶排序"><br>A中就是给出的数据，这些数据都是0到1之间的数，B中就是我们准备的10个桶，数字0到9表示的是数据小数点后一位的数。<br><img src="/2019/07/28/线性时间排序/21.png" alt="桶排序"><br>开始进行排序，第一个数字是0.78，所以放在了7号桶里面。<br><img src="/2019/07/28/线性时间排序/22.png" alt="桶排序"><br>当进行到0.72时依然是放到7号桶里面，不过要和0.78比较一下大小，然后进行排序。<br><img src="/2019/07/28/线性时间排序/23.png" alt="桶排序"><br>最后的排序结果，如图所示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线性时间排序&quot;&gt;&lt;a href=&quot;#线性时间排序&quot; class=&quot;headerlink&quot; title=&quot;线性时间排序&quot;&gt;&lt;/a&gt;线性时间排序&lt;/h3&gt;&lt;p&gt;对于比较排序来说，在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们可以看到下图中的比较排序算法，在
      
    
    </summary>
    
      <category term="算法导论" scheme="http://bowiee.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://bowiee.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读：Maverick: Discovering  Exceptional  Facts  from  Knowledge  Graphs</title>
    <link href="http://bowiee.github.io/2019/07/27/Maverick/"/>
    <id>http://bowiee.github.io/2019/07/27/Maverick/</id>
    <published>2019-07-27T15:33:08.000Z</published>
    <updated>2019-07-27T15:39:38.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="论文阅读：Maverick-Discovering-Exceptional-Facts-from-Knowledge-Graphs"><a href="#论文阅读：Maverick-Discovering-Exceptional-Facts-from-Knowledge-Graphs" class="headerlink" title="论文阅读：Maverick: Discovering  Exceptional  Facts  from  Knowledge  Graphs"></a>论文阅读：Maverick: Discovering  Exceptional  Facts  from  Knowledge  Graphs</h3><p><a href="https://dl.acm.org/citation.cfm?doid=3183713.3183730" target="_blank" rel="noopener">原文链接</a><br>参考资料：<br><a href="https://www.bilibili.com/video/av17996145?from=search&seid=10273290250819735348" target="_blank" rel="noopener">知识图谱介绍</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">论文题目：Robust Entity Resolution using Random Graphs</span><br><span class="line">发表时间：SIGMOD’18,June  10-15, 2018, Houston, TX, USA</span><br><span class="line">论文作者：Gensheng Zhang 、 Damian Jimenez、 Chengkai Li</span><br></pre></td></tr></table></figure><p>论文作者详细资料：</p><p><img src="/2019/07/27/Maverick/01.jpg" alt="Gensheng Zhang"><br>2002-2006武汉大学。2010-2012南达科他州立大学。2012年至今德克萨斯大学阿灵顿分校<br>研究方向：数据挖掘，图形挖掘，数据库<br><img src="/2019/07/27/Maverick/02.png" alt="Damian Jimenez"><br>德克萨斯大学阿灵顿分校博士。<br>研究兴趣：NLP，神经网络。<br><img src="/2019/07/27/Maverick/03.png" alt="Chengkai Li"><br>Chengkai Li博士是德克萨斯大学阿灵顿分校计算机科学与工程系副教授，创新数据库与信息系统研究实验室（IDIR）主任。</p><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>这篇论文的题目是从知识图谱中发现异常事实，所以首先要了解知识图谱。<br>知识图谱是一个将现实世界映射到数据世界，由结点和边组成的语义网络。其中结点代表物理世界的结点或者概念，边代表实体的属性或者结点的关系。因为现实世界中的物体充满着各种各样的关系，知识图谱就是一种合理摆放他们的方式。<br><img src="/2019/07/27/Maverick/04.png" alt="知识图谱"><br>例如在上图就是知识图谱，其中结点表示了，人物和水果。例如最上面那条边，表示了May喜欢橘子这个水果。<br><img src="/2019/07/27/Maverick/05.png" alt="知识图谱的应用"><br>其实知识图谱最开始是由Google提出的，为的就是解决搜索的问题，例如我们可以在谷歌上搜索居里夫人。<br><img src="/2019/07/27/Maverick/06.png" alt="居里夫人"><br>我们可以在搜索界面上看到这样的结果，在右边红色方框的结果就是因为有知识图谱的帮助，所以可以很快的显示出结果。其中左边显示的结果，她是唯一获得两种不同学科诺贝尔奖的人，也是巴黎大学的第一位女教授，这个就是我们要找的特殊事实。<br><img src="/2019/07/27/Maverick/07.png" alt="Maverick"><br>Maverick就是这篇论文提出的处理系统，现实世界里的各种知识会被总结为知识图谱，这个时候，如果我们想了解居里夫人的特殊事实，就对Maverick输入居里夫人，最后会得出关于居里夫人的前k个特殊事实。</p><h4 id="Our-Approach"><a href="#Our-Approach" class="headerlink" title="Our Approach"></a>Our Approach</h4><p><img src="/2019/07/27/Maverick/08.png" alt="关于世界杯的知识图谱"><br>这是关于世界杯的知识图谱中的一部分，S表示运动员，G表示一个进球。ESP表示西班牙，BRA表示巴西，CRO表示克罗地亚。边上的play-for表示某球员是属于某个国家的，scored-by表示这个进球是由指向球员踢进的，awarded-to,表示进球的这一分，是属于指向的球队的，图中红色圆圈的部分，表示的是：巴西国家队的球员S3踢进了G3这个进球，这一分属于巴西队。<br><img src="/2019/07/27/Maverick/09.png" alt="知识图谱"><br>我们可以看到G1，G2，G3这三个进球中，只有G1是属于克罗地亚队得分的球，其他球是巴西队得分，所以在所有进球的这个背景中，G1是属于特殊的那一个，而且我们还可以发现，G1是一个乌龙球，也与其他两球不同。<br><img src="/2019/07/27/Maverick/10.png" alt="知识图谱"><br>那在知识图谱中是如何得出G1是一个乌龙球的呢？首先找出G1,G2,G3这三个进球，所踢进的球员，以及这些球员效力的国家队，也就是在右边的三个Match。<br><img src="/2019/07/27/Maverick/11.png" alt="Context"><br>因为我们现在是要找出，这三个球中的特殊情况，所以必须要放在一定的背景里，才能发现其中的不同，比如我们说居里夫人是唯一得过两次不同学科诺贝尔奖的人，是把她放在所有得过诺贝尔奖的人里去比较得来的。所以，这里我们将这些球都放在巴西队进球的这个背景里，那可以从这个背景里得出怎么样的结论呢，再根据每个进球边上的awarded-to属性，可以得出G1是一个不同的进球，它是一个乌龙球。<br><img src="/2019/07/27/Maverick/12.png" alt="Maverick"><br>前文所讲，我们需要通过知识图谱上面的各种Match找出各种模式，最后的结果就是找到Context，也就是找到我们应该放到什么背景里去比较。这个图那就是代表Maverick的一整个执行流程。<br>首先左上角是知识图谱，Maverick将其中的模式都通过Pattern Generator来生成，再结合context（也就是比较的背景）放到Exceptionality Evaluator中，来选出前k个特殊事实。<br><img src="/2019/07/27/Maverick/13.png" alt="Pattern Generator"><br>那模式构造是怎么样的呢？这里是通过树来构造的，比如这里根结点的g表示的就是所有的进球，g的子节点，就多了一些限制，比如第一个，表示球员S1踢进的所有进球。<br><img src="/2019/07/27/Maverick/14.png" alt="生产Pattern Tree"><br>生产的过程，就是首先根据根节点p0，这里也就是g，通过Context Evaluator来寻找到和g有关的match，最后总结出新的模式，得到p1,p2,p3,p4。<br><img src="/2019/07/27/Maverick/15.png" alt="Beam-search"><br>如果去进行所有的评判，那工作量太大，所以我们只能选出一部分Pattern去进行比较，这里使用集束搜索，设定宽度为2，再使用启发式算法，选出满足要求的两个。<br><img src="/2019/07/27/Maverick/16.png" alt="Maverick工作流程"><br>在进行完Pattern Tree的构建后，Maverick的流程图变为上图所示。现在只剩下，异常评估的这一部分，还没有完成。我们判断异常必须要结合属性，所以在这一块，会将属性构建为属性树。<br><img src="/2019/07/27/Maverick/17.png" alt="属性树"><br>在构建属性树时，也会遵循一定的规则，如果这里有三个属性，a1,a2,a3，会按照这个顺序，如上图所示，进行树的构建。<br><img src="/2019/07/27/Maverick/18.png" alt="属性树"><br>但是为了减少工作量，也会对其进行减少，会设定一个阈值达到的就保留，无法达到的就去掉。<br><img src="/2019/07/27/Maverick/19.png" alt="Maverick"><br>这个就是处理问题完整的流程图，选出top-k个异常值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;论文阅读：Maverick-Discovering-Exceptional-Facts-from-Knowledge-Graphs&quot;&gt;&lt;a href=&quot;#论文阅读：Maverick-Discovering-Exceptional-Facts-from-Knowle
      
    
    </summary>
    
      <category term="论文阅读" scheme="http://bowiee.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="论文" scheme="http://bowiee.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读：Robust Entity Resolution using Random Graphs</title>
    <link href="http://bowiee.github.io/2019/07/26/Robust-Entity-Resolution/"/>
    <id>http://bowiee.github.io/2019/07/26/Robust-Entity-Resolution/</id>
    <published>2019-07-26T14:17:25.000Z</published>
    <updated>2019-07-26T14:31:52.239Z</updated>
    
    <content type="html"><![CDATA[<h3 id="论文阅读：Robust-Entity-Resolution-using-Random-Graphs"><a href="#论文阅读：Robust-Entity-Resolution-using-Random-Graphs" class="headerlink" title="论文阅读：Robust Entity Resolution using Random Graphs"></a>论文阅读：Robust Entity Resolution using Random Graphs</h3><p><a href="https://dl.acm.org/citation.cfm?doid=3183713.3183755" target="_blank" rel="noopener">原文链接</a><br>参考资料：<br><a href="https://blog.csdn.net/chndata/article/details/41646665" target="_blank" rel="noopener">数据中国</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">论文题目：Robust Entity Resolution using Random Graphs</span><br><span class="line">发表时间：SIGMOD’18, June 10-15, 2018, Houston, TX, USA</span><br><span class="line">论文作者：Sainyam Galhotra 、 Donatella Firmani、 Barna Saha 、Divesh Srivastava</span><br></pre></td></tr></table></figure><h4 id="Indroduction"><a href="#Indroduction" class="headerlink" title="Indroduction"></a>Indroduction</h4><p>论文的意思是利用随机图，来完成实体解析(Entity Resolution),那么何为实体解析呢？<br>根据《实体解析与信息质量》，可以了解到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实体解析（Entity Resolution）是一种用于判断两条记录是否指向同一事物的过程。</span><br><span class="line">实体这个术语描述了过程的目标是真实世界的事物，比如某个人，地点或者物品。</span><br><span class="line">而解析则描述了回答这样的一个问题的过程：两条不同记录是否指向了同一个真实实体？</span><br></pre></td></tr></table></figure><p>尽管实体解析的定义描述的是两条记录之间的关系，但事实上，这个定义也可以被延伸到一个更大的记录集合上，相应的，该过程的输出则聚合了指向同一实体的所有记录的子集/簇。在这样的上下文中，ER的定义也可以解释为：“识别并整合所有定义同一真实世界实体的记录的过程”（Benjelloun,Garcia-Molina, Menestrina, et al., 2009）。<br><img src="/2019/07/26/Robust-Entity-Resolution/01.png" alt="实体解析"><br>例如在上图中，实体解析的意思就是，判断出有哪一些表示的是同一个物体，比如上面的iPhone Two和iPhone 2表示的就是同一个手机。<br><img src="/2019/07/26/Robust-Entity-Resolution/02.png" alt="实体解析"><br>又如上图中，实体解析就是选出哪些照片表示的是同一个人，这里有古天乐，周星驰，张震。</p><h4 id="Previous-approach"><a href="#Previous-approach" class="headerlink" title="Previous approach"></a>Previous approach</h4><p>这里介绍以前的方法，我们用上面提到的判断照片是否是同一个人举例，这样做的前提是我们已经得出了，这两个照片是同一个人的概率是多少。怎么得出呢，微软提供了这个服务。<br><a href="http://www.twinsornot.net" target="_blank" rel="noopener">Microsoft tool TwinsOrNot</a><br>可以在这个网站，上传照片进行对比识别。<br><img src="/2019/07/26/Robust-Entity-Resolution/03.png" alt="概率图"><br>在进行完，上传对比之后，我们可以得到，上面的概率图，其中绿色就表示为同一个人概率超过0.5的，红色就是低于0.5，线越粗，概率越高，红色虚线说明概率极低。得到概率图之后，就要在此图上运用方法找出所有同一个人的照片了。<br><img src="/2019/07/26/Robust-Entity-Resolution/04.png" alt="基于绿色连接的寻找"><br>在这种方法里，只要是绿色连接的照片我们就认为是同一个人，以此来进行划分，得到结果。显然这种方法并不准确，高度依赖于事先判断的概率，这里就把张震和周星驰当作了同一个人。<br><img src="/2019/07/26/Robust-Entity-Resolution/05.png" alt="基于相似度"><br>每条边上都有相似的概率，这种方法就是把概率特别相近的划分到一起，当作是同一个人。我们可以从上图中看到，这种方法也是错误的，它并没有把所有的周星驰照片都找出来（因为年轻的周星驰和年老的周星驰相似概率并不高）。<br><img src="/2019/07/26/Robust-Entity-Resolution/06.png" alt="正确的划分"><br>正确的划分得到的应该是如图所示的这样，分成了三个组，找出了古天乐、周星驰、张震。<br>为了准确的找出所有的人，引入了Oracle这个概念，并不是指的数据库公司，而是表示为一种众包的抽象。因为在很多情况下，人去判断是否相似，是要比计算机容易很多的。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Online advertising = Internet ad</span><br></pre></td></tr></table></figure><p>人们可以很快的判断出这两者都是网络广告的意思，但计算机却很困难，所以提出的Oracle相当于是一个系统，可以回到如下的问题。<br><img src="/2019/07/26/Robust-Entity-Resolution/07.png" alt="Oracle"><br>而且我们假定，Oracle总是会回答正确。<br>我们有了Oracle，并且Oracle总是会给出正确的答案，显然可以通过Oracle来回答两张照片是否是同一个人这种问题。那应该如何觉得询问的顺序呢？也就是应该选择哪两张照片去询问呢。<br><img src="/2019/07/26/Robust-Entity-Resolution/08.png" alt="询问顺序"><br>这里有两种方式，其一就是普通的方式，随机选取一对进行询问，显然这种方法是耗时、耗力的。其二就是聪明的方法，根据概率的大小去进行询问，先询问概率大的，因为他们更可能是同一个人。<br>通常来说，以前使用的方法就是按照边的概率进行询问的方法。<br><img src="/2019/07/26/Robust-Entity-Resolution/09.png" alt="按边的概率询问"><br>在这里我们先访问古天乐那条边，得到的结果是是同一个人。<br><img src="/2019/07/26/Robust-Entity-Resolution/10.png" alt="按边的概率询问"><br>然后询问其他的边，得出了正确你的结果。<br><img src="/2019/07/26/Robust-Entity-Resolution/11.png" alt="按边的概率询问"><br>在询问完成后，得出了正确的结果，完成了实体解析。<br><img src="/2019/07/26/Robust-Entity-Resolution/12.png" alt="询问错误的结果"><br>我们假设的是Oracle总是给出正确的结果，但是如果Oracle给出了错误的结果，<br>例如在上图中把周星驰和张震当作一个人，那么我们最后的实体解析就是错误的。<br><img src="/2019/07/26/Robust-Entity-Resolution/13.png" alt="错误的结果"></p><h4 id="Our-approach"><a href="#Our-approach" class="headerlink" title="Our approach"></a>Our approach</h4><p>以前的方法，都是假设Oracle一定会回答正确，但是实际情况中Oracle并不总能回答正确，会得到错误的结果。所以这篇论文就提出了，一个纠正错误的工具。<br><img src="/2019/07/26/Robust-Entity-Resolution/14.png" alt="实体解析处理流程"><br>这是这篇论文中，实体解析的处理流程，实现进行记录的收集，也就是上图的收集那些照片，再之后就是使用前文所讲的策略，以及本文提出的纠错层。<br>这个纠错层的关键思想有两方面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在并入新结点时，进行多次的判断。</span><br><span class="line">通过合并以及分裂过程来进行纠错。</span><br></pre></td></tr></table></figure><p><img src="/2019/07/26/Robust-Entity-Resolution/15.png" alt="并入新结点"><br>在并入新结点时，我们不再只是查询一对，而是查询许多对，如上图中要将New Node并入其中时，我们会对许多对进行判断，如果相似的值达到了阈值，则认为时一个人，将新结点放入其中。</p><p><img src="/2019/07/26/Robust-Entity-Resolution/16.png" alt="合并过程"><br>合并过程主要是为了提高recall，也就是召回率，意思就是希望可以找到所有的同一个人照片。主要的过程就是，在两个聚类中的结点，不断的进行询问，判断是否为一个人，然后决定是否合并。<br><img src="/2019/07/26/Robust-Entity-Resolution/17.png" alt="分裂过程"><br>在已经完成的聚类里面，会存在Low confidence node ，就是纸盒部分结点连接，比如图中的张震，这种结点，就很有可能，并不属于这个聚类。所以我们应该想办法对其进行判断。<br><img src="/2019/07/26/Robust-Entity-Resolution/18.png" alt="分裂过程"><br>解决的办法，就是判断Low confidence node和其他结点的相似度，如图中，判断出不相似，那就将其剔除。<br>前文所说，这是一个纠错的工具，所以会有使用上面的不同，这里介绍了三种不同的使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法一：</span><br><span class="line">Eager:每一次查询，都使用这个纠错的工具。这样会降低效率，召回率降低，就是不</span><br><span class="line">能找到所有的同一个人的照片，但是准确度会变高。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用方法二：</span><br><span class="line">Lazy:不使用纠错的工具。这样会让准确度降低，但是召回率变高。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法三：</span><br><span class="line">Adaptive pipeline:高概率的结点就不适用纠错工具，就是两张已经很相似的照片，不</span><br><span class="line">会再使用工具询问。</span><br></pre></td></tr></table></figure><h4 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h4><p><img src="/2019/07/26/Robust-Entity-Resolution/19.png" alt="实验结果"><br>上图是在不同的数据集上做的实验，横坐标表示查询的数量，纵坐标表示效果，得分越高，效果越好，从图中看出，Adaptive pipeline的效果是非常好的，仅次于理想情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;论文阅读：Robust-Entity-Resolution-using-Random-Graphs&quot;&gt;&lt;a href=&quot;#论文阅读：Robust-Entity-Resolution-using-Random-Graphs&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="论文阅读" scheme="http://bowiee.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="论文" scheme="http://bowiee.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读：Dynamic Bike Reposition: A Spatio-Temporal Reinforcement Learning Approach</title>
    <link href="http://bowiee.github.io/2019/07/25/Dynamic-Bike-Reposition/"/>
    <id>http://bowiee.github.io/2019/07/25/Dynamic-Bike-Reposition/</id>
    <published>2019-07-25T11:11:00.000Z</published>
    <updated>2019-07-26T02:46:29.449Z</updated>
    
    <content type="html"><![CDATA[<p>论文标题：通过强化学习，实现自行车的动态调配<br><a href="https://dl.acm.org/citation.cfm?doid=3219819.3220110" target="_blank" rel="noopener">原文链接</a><br>参考资料：<br><a href="https://morvanzhou.github.io/" target="_blank" rel="noopener">莫凡的个人网站</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">论文题目：Dynamic Bike Reposition: A Spatio-Temporal Reinforcement Learning Approach</span><br><span class="line">发表时间：KDD 2018，August 19-23,2018</span><br><span class="line">论文作者：Yenxin Li   Yu Zheng   Qiang Yang</span><br></pre></td></tr></table></figure><p>论文作者详细介绍：<br><img src="/2019/07/25/Dynamic-Bike-Reposition/42.png" alt="Yenxin Li(未找到照片)"><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Yenxin Lin是香港科技大学的学生<br><img src="/2019/07/25/Dynamic-Bike-Reposition/25.jpg" alt=" Qiang Yang"><br>&emsp;&emsp;&emsp;&emsp;杨教授现任香港科技大学计算机科学与工程系讲师。他的研究兴趣包括机器学习，人工智能和数据挖掘。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/26.jpg" alt="Yu Zheng"><br>&emsp;&emsp;&emsp;&emsp;京东金融副总裁，首席数据科学家。 主要任务是利用大数据和人工智能技术解决交通和城市规划等城市挑战。<br><strong>1.Introduction</strong><br>这篇文章所讲的自行车的动态调配，并不是指的共享单车，而是下图所示的比较传统的自行车站，这主要是因为课题研究的时候，共享单车还没有火，并且论文所使用的数据是英国的数据，那边没有共享单车。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/27.jpg" alt="公用自行车"><br>在整个地区的自行车站点里，总是会有一些站点缺少自行车，而有些站点的自行车过多，一般需要通过运输的方式将自行车进行调配，这篇论文解决的就是如何调配，也就是应该从哪一个站点运输多少辆自行车到其他某个站点去。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/01.png" alt="调度"><br><strong>2.Our approach</strong><br>一个市的面积是很大的，我们不可能在整个市的所有自行车站点之间进行自行车的调配，这是不必要的，同时也会浪费大量的人力、物力、财力，所以我们应该减少，调配自行车的范围，比如现在有7个自行车站点，我们不会在这7个站点之间进行自行车的调配。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/02.png" alt="自行车站点"><br>在这7个站点，我们会根据规则对其进行划分，规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.两个站点之间的距离要接近，相隔太远是无法划分到一个区域里面的。</span><br><span class="line">2.有着相同的行车轨迹，比如小区周围的自行车站，都会到一些办公的区域去，这就是共同的行车轨迹。</span><br></pre></td></tr></table></figure><p>最后这7个站点，可以根据这些规则划分为两个区域（这里只是举个例子）：<br><img src="/2019/07/25/Dynamic-Bike-Reposition/03.png" alt="区域1-某居住区"><br><img src="/2019/07/25/Dynamic-Bike-Reposition/04.png" alt="区域2-某工作区"><br>因为这些区域地理位置相近，且行车轨迹也大致相同，现在我们将分好的区域作为单位去考虑自行车调配的问题，但是即便如此，从城市的角度来看，我们也不需要在所有不同的区域之间进行自行车的调配。比如在下面的上海地图中，上面的圆圈表示的就是区域，人们一般不会从松江骑个车到静安区，所以考虑整个城市所有区域的调配是不必要的。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/06.png" alt="上海市"><br>所以，我们可以将区域分成不同的组，只在组之间进行调配，这样可以大大的节省下资源。显然，现在的问题，就是应该如何去分组保证调配的合理。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/05.png" alt="区域分组"><br>区域分组的过程分成了三个步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Step 1:根据这两个区域之间的通勤记录进行连接，通行频率高于给定阈值的就进行连接。</span><br><span class="line">Step 2:社区发现，一个区域连接的不同区域越多，说明越有可能形成一个社区，只与几个相连，那我们就将这个连接给去掉。</span><br><span class="line">Step 3:将那些剩下的结点，根据已有的聚类算法，合并到某个组去。</span><br></pre></td></tr></table></figure><p><img src="/2019/07/25/Dynamic-Bike-Reposition/20.png" alt="将区域进行分组"><br>现在已经完成了区域分组，我们只会在组内，进行自行车的调配，组与组之间的调配，我们是忽略不计的。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/21.png" alt="完成了区域分组"><br>到现在，要解决的问题就是，如何在组内进行自行车的调配，也就是找到调配自行车的策略，这篇论文使用的就是强化学习的方法。所以下面简要的介绍一下，强化学习是什么：<br><img src="/2019/07/25/Dynamic-Bike-Reposition/08.png" alt="强化学习"><br>强化学习就是像图中的小朋友一样，一开始什么都不懂，然后经过不断的试错，掌握了知识，找到了正确的方法。<br>强化学习就像是一个人，第一次见到火，他不知道这是什么。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/22.jpg" alt="强化学习"><br>但是他感觉到了温暖，所以他觉得火是好的，并且想要更靠近火。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/23.jpg" alt="强化学习"><br>在触碰了之后，被火给烫到了，他学会了不能离的太近，也不能去触碰火。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/24.jpg" alt="强化学习"><br>在经过这一学习过程后，他学会了，要适当的保持距离，不能触碰。<br>强化学习就如下图所示，我们做出某些行为，得到反馈，我们对环境进行观察，最后不断学习的过程。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/40.png" alt="强化学习过程"><br>强化学习的分类方法有很多，这里的分类就是按是否基于模型来分类的，下面进行详细的介绍。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/10.png" alt="不基于模型的强化学习"><br>不基于模型的强化学习，就是只能通过现有的观察来得出结论，进行学习。比如这里有一个机器人，它想知道在地球上扔一个原子弹会发生什么，它这样做了，然后把自己给炸死了。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/09.png" alt="基于模型的强化学习"><br>基于模型的强化学习，现在这个机器人也要做同样的事情，但是它是基于模型的，所以它拥有了想象力，它可以再做出一个地球的模型，然后在这个假的地球上做实验，得出结论。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/11.png" alt="不基于模型的强化学习"><br>Model-Free RL只能够做一步，看看反应，然后再做，最后完成学习的过程，它是没有想象力的。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/12.png" alt="基于模型的强化学习"><br>Model-Based RL就是可以想象出做了之后的事情，然后可以从中选择一个去执行。<br>下面是用神经网络实现的强化学习过程，输入现在的状态和动作，神经网络会根据反馈给这个动作打一个分。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/13.png" alt="强化学习"><br>回到论文中来，我们会利用强化学习，来完成自行车调配问题，输入现在各自行车站点的信息，比如数量，和运输车的信息，再还要输入可能会做的许多的调配行动，选择神经网络里面分数最高的一个去执行。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/14.png" alt="神经网络学习"><br>为了让神经网络能判断的更准确，还加入了一个模拟器，用来模拟自行车的归还需求，以及租界需求，当然是在一定的时间里面进行的模拟。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/16.png" alt="模拟器"><br>在这个过程里，根据神经网络的判断进行自行车的运输，之后会得到反馈，这些记录都存放在样本池里面，用来供神经网络学习，使其判断的更准确。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/15.png" alt="学习过程"><br>自行车的动态调配过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Cluster : 在图中的Region Clusters部分，也就是上文所讲的分组过程，我们只会在组内进行自行车的调配。</span><br><span class="line">2.Current state : 将现在的状态输入，也就是天气、自行车数量、运输车位置。</span><br><span class="line">3.network ： 通过神经网络来确定我们所要执行的调配策略。</span><br><span class="line">4.Reposition : 执行这个调配自行车的动作。</span><br></pre></td></tr></table></figure><p><img src="/2019/07/25/Dynamic-Bike-Reposition/17.png" alt="自行车的动态调配过程"><br><strong>3.Experiment</strong><br>图中的数字表示的是顾客减少量，也就是没有骑到自行车的人，从图中我们可以看到，使用STRL也就是本文所介绍的方法，顾客的损失量是最少的，也即是效果最好。<br><img src="/2019/07/25/Dynamic-Bike-Reposition/41.png" alt="Customer loss in the morning rush hours "></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;论文标题：通过强化学习，实现自行车的动态调配&lt;br&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?doid=3219819.3220110&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;参考资料：
      
    
    </summary>
    
      <category term="论文阅读" scheme="http://bowiee.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="论文" scheme="http://bowiee.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>eclipse导入java项目后，出现错误提示的解决办法</title>
    <link href="http://bowiee.github.io/2019/07/25/eclipse%E5%AF%BC%E5%85%A5java%E9%A1%B9%E7%9B%AE/"/>
    <id>http://bowiee.github.io/2019/07/25/eclipse导入java项目/</id>
    <published>2019-07-25T11:07:57.000Z</published>
    <updated>2019-07-26T02:52:19.183Z</updated>
    
    <content type="html"><![CDATA[<p>在将一个java项目导入后，可能会出现许多的错误提示，例如：<br><img src="/2019/07/25/eclipse导入java项目/01.png" alt="错误提示"></p><p>这些错误可能是由于jdk版本不同所导致的，那应该如何解决呢？<br>1.右键项目，点击Build Path中的Configuer  Build Path<br><img src="/2019/07/25/eclipse导入java项目/02.png" alt="找到Configuer  Build Path "><br>2.在Libraries中将那个有红叉的JRE的移除，再点击Add Library,添加新的<br><img src="/2019/07/25/eclipse导入java项目/03.png" alt="移除JRE并添加"><br>3.在出现的弹窗里选择JRE System Library，一直点下去就好了。<br><img src="/2019/07/25/eclipse导入java项目/04.png" alt="点击next"><br><img src="/2019/07/25/eclipse导入java项目/05.png" alt="点击Finish"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在将一个java项目导入后，可能会出现许多的错误提示，例如：&lt;br&gt;&lt;img src=&quot;/2019/07/25/eclipse导入java项目/01.png&quot; alt=&quot;错误提示&quot;&gt;&lt;/p&gt;
&lt;p&gt;这些错误可能是由于jdk版本不同所导致的，那应该如何解决呢？&lt;br&gt;1.右键
      
    
    </summary>
    
      <category term="踩过的坑" scheme="http://bowiee.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="java" scheme="http://bowiee.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>安装Mysql时端口号3306被占用的处理方法</title>
    <link href="http://bowiee.github.io/2019/07/25/%E5%AE%89%E8%A3%85Mysql%E6%97%B6%E7%AB%AF%E5%8F%A3%E5%8F%B73306%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>http://bowiee.github.io/2019/07/25/安装Mysql时端口号3306被占用的处理方法/</id>
    <published>2019-07-25T11:06:22.000Z</published>
    <updated>2019-07-25T14:08:52.518Z</updated>
    
    <content type="html"><![CDATA[<p>有些情况下端口号3306会被占用，例如我们卸载了Mysql重新安装时就会出现这种情况。<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/01.png" alt="端口号被占用"><br>解决方案如下：<br>1.打开命令窗口（windows+R,输入cmd）<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/02.png" alt="打开命令窗口"><br>2.输入命令  netstat -ano（查看端口的使用情况）<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/03.png" alt="端口号使用情况"><br>同时我们需要记住，后面的PID数字，也就是这里的4748<br>3.打开任务管理器<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/04.png" alt="打开任务管理器"><br>4.点击查看详细信息<br><img src="/2019/07/25/安装Mysql时端口号3306被占用的处理方法/05.png" alt="查看详细信息"><br>在这里可以点击PID，它会按照从小到大的顺序排列，之后找到4478，右键关闭即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些情况下端口号3306会被占用，例如我们卸载了Mysql重新安装时就会出现这种情况。&lt;br&gt;&lt;img src=&quot;/2019/07/25/安装Mysql时端口号3306被占用的处理方法/01.png&quot; alt=&quot;端口号被占用&quot;&gt;&lt;br&gt;解决方案如下：&lt;br&gt;1.打开命令窗口
      
    
    </summary>
    
      <category term="踩过的坑" scheme="http://bowiee.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="mysql" scheme="http://bowiee.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JDBC的连接设置问题</title>
    <link href="http://bowiee.github.io/2019/07/25/jdbc%E7%9A%84%E8%BF%9E%E6%8E%A5/"/>
    <id>http://bowiee.github.io/2019/07/25/jdbc的连接/</id>
    <published>2019-07-25T11:04:10.000Z</published>
    <updated>2019-07-25T11:05:53.063Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql版本：community-5.7.17.0</span><br></pre></td></tr></table></figure><p>在连接时，需要书写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/web01?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure><p>上面的useUnicode=true&amp;characterEncoding=UTF-8都是用来完成编码的设置，而useSSL=true建立SSLl连接。如果未明确设置，MySQL 5.5.45+, 5.6.26+ and 5.7.6+版本默认要求建立SSL连接。 若未设置，则会出现下列警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WARN: Establishing SSL connection without server’s identity verification is not recommended. </span><br><span class="line">According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. </span><br><span class="line">For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. </span><br><span class="line">You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</span><br></pre></td></tr></table></figure><p>在jdbc的配置中如果myaql是6.0及以上的，会有所不同，需要按照以下设置驱动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>否则就会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loading class &apos;com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is &apos;com.mysql.cj.jdbc.Driver&apos;. </span><br><span class="line">The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</span><br></pre></td></tr></table></figure><p>同时mysql 6.0以上还需要设置时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://&lt;u&gt;localhost&lt;/u&gt;:3306/ssm_spring?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=UTC</span><br></pre></td></tr></table></figure><p>不过值得注意的是UTC代表的是全球标准时间，我们使用的是北京时区，领先UTC八个小时。所以我们可以将时区设置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="踩过的坑" scheme="http://bowiee.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="mysql" scheme="http://bowiee.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>错误提示：The reference to entity &quot;useSSL&quot; must end with the &#39;;&#39; delimiter.</title>
    <link href="http://bowiee.github.io/2019/07/25/XML%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
    <id>http://bowiee.github.io/2019/07/25/XML中的特殊字符/</id>
    <published>2019-07-25T11:00:46.000Z</published>
    <updated>2019-07-25T11:02:26.939Z</updated>
    
    <content type="html"><![CDATA[<p>###XML中的特殊字符<br>XML中总共有5个特殊字符，如果配置文件中要写这些特殊字符的话，就需要进行特别处理。</p><p>使用XML转义序列表示这些特殊的字符，这5个特殊字符所对应XML转义序列为：</p><blockquote><p>&amp; 替换为 &amp;amp;<br>&lt; 替换为 &amp;lt;<br>&gt; 替换为 &amp;gt;<br>&quot;  替换为 &amp;quot;<br>&#39;  替换为 &amp;apos;<br>（后面的 ; 替换字符中的一部分，也要一起写入的）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###XML中的特殊字符&lt;br&gt;XML中总共有5个特殊字符，如果配置文件中要写这些特殊字符的话，就需要进行特别处理。&lt;/p&gt;
&lt;p&gt;使用XML转义序列表示这些特殊的字符，这5个特殊字符所对应XML转义序列为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;amp; 替换为 &amp;a
      
    
    </summary>
    
      <category term="知识总结" scheme="http://bowiee.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://bowiee.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读: Streaming Graph Partitioning: An Experimental Study</title>
    <link href="http://bowiee.github.io/2019/07/25/Streaming-Graph-Partitioning/"/>
    <id>http://bowiee.github.io/2019/07/25/Streaming-Graph-Partitioning/</id>
    <published>2019-07-25T10:45:57.000Z</published>
    <updated>2019-07-26T06:36:36.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="论文阅读：Streaming-Graph-Partitioning-An-Experimental-Study"><a href="#论文阅读：Streaming-Graph-Partitioning-An-Experimental-Study" class="headerlink" title="论文阅读：Streaming Graph Partitioning: An Experimental Study"></a>论文阅读：Streaming Graph Partitioning: An Experimental Study</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">论文标题：Streaming Graph Partitioning: An Experimental Study</span><br><span class="line">发表：PVLDB, 11(11): 1590-1603, 2018</span><br><span class="line">作者：Zainab Abbas、Vasiliki Kalavri、Paris Carbone、Vladimir Vlassov</span><br></pre></td></tr></table></figure><p><a href="href=" http: www.vldb.org pvldb vol11 p1590-abbas.pdf"">原文连接</a></p><h4 id="作者详细介绍："><a href="#作者详细介绍：" class="headerlink" title="作者详细介绍："></a>作者详细介绍：</h4><p><img src="/2019/07/25/Streaming-Graph-Partitioning/01.png" alt="Zainab Abbas"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名：Zainab Abbas</span><br><span class="line">院校：皇家理工学院（瑞典）的研究生</span><br></pre></td></tr></table></figure><p><img src="/2019/07/25/Streaming-Graph-Partitioning/02.png" alt="Vasiliki Kalavri"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名：Vasiliki Kalavri</span><br><span class="line">院校：皇家理工学院（瑞典）的博士</span><br><span class="line">研究方向：分布式数据处理和大规模图形分析</span><br></pre></td></tr></table></figure><p><img src="/2019/07/25/Streaming-Graph-Partitioning/03.png" alt="Paris Carbone"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名：Paris Carbone</span><br><span class="line">院校：皇家理工学院（瑞典）的博士</span><br><span class="line">研究方向：分布式系统、数据管理</span><br></pre></td></tr></table></figure><p><img src="/2019/07/25/Streaming-Graph-Partitioning/04.png" alt="Vladimir Vlassov"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名：Vladimir Vlassov</span><br><span class="line">院校：皇家理工学院（瑞典）的教授</span><br><span class="line">研究方向：数据密集型计算和流处理; 云资源管理; 基于云的服务和应用程序</span><br></pre></td></tr></table></figure><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h4><p>现实世界数据量十分巨大，而这些数据大多都是用图来表示的（如下图所示），所以处理图的数据，对现实世界是至关重要的。而在计算中，图的分布式计算是重要的，分布式计算，必然带来图的分区。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/05.png" alt="社交信息"></p><p><img src="/2019/07/25/Streaming-Graph-Partitioning/06.png" alt="神经信息"></p><p>在进行分区之前，我们来看看完整的处理图数据的过程<br><img src="/2019/07/25/Streaming-Graph-Partitioning/07.png" alt="图数据处理流程"></p><p>大致上分为三步， 首先将图数据加载，然年后进行分区，最后是计算过程。在分区之前，通用图分区方法扫描完整图以获得结构特征。 然而，对低延迟，连续图形分析的新兴需求导致了在线分区方法的发展。 在线方法将边或顶点作为流摄取，而不是提前完整的加载。</p><p><strong>在图处理过程中一般的图分区方法</strong><br><img src="/2019/07/25/Streaming-Graph-Partitioning/08.png" alt="一般的图分区方法"></p><p>分为两种，也就是Edge-cut和Vertex-cut，Edge-cut的意思就是切边，对结点进行分区，让边跨越各个分区，这种方法不需要构造其他结点。Vertex-cut就是切结点，对边进行分区，会判断每条边应属于哪一个区，显然不同的边有可能连接着同一个结点，并且这些边也分在不同的区，所以结点要进行复制，跟着边走，边在哪里，结点就在哪里。如图所示，复制了z结点，以及d结点。</p><p><strong>流图分区</strong><br>所以对于这篇论文所讲的流图分区来说，主要也是这两种方法。<br>流图分区中的流，分为两种，一种是边流，一种是结点流。边流就是不断有边数据流入，然后对其判断边属于哪个分区。结点流就是以结点的形式流入。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/09.png" alt="流图分区"></p><h4 id="Streaming-Graph-Partitioning"><a href="#Streaming-Graph-Partitioning" class="headerlink" title="Streaming Graph Partitioning"></a><strong>Streaming Graph Partitioning</strong></h4><p>本文所讲的流图分区，大致分为三类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Vertex Partitioning Methods（结点流，对结点进行分区）</span><br><span class="line">2. Edge Partitioning Methods （边流，对边进行分区）</span><br><span class="line">3. Model-Agnostic (其他方法，混合各种方法使用)</span><br></pre></td></tr></table></figure><ul><li><strong>Vertex Partitioning Methods(按结点的分区方法)</strong><br>按结点分区的大致过程如下图所示，左边表示原始图形，共有6个结点（0，1，2，3，4，5），上面的表格表示图的输入顺序，（0：1）表示输入的是0号节点，同时记录和它相邻的结点1号。这里输入的顺序是随机的。结点的分区共有三个，分区数量是提前确定的。最后生成右下角的分区图形。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/10.png" alt="Vertex Partitioning Methods"></li></ul><p>这个分区方法所使用的原理就是<strong>Linear Deterministic Greedy (LDG)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线性确定性贪婪分区（LDG）尝试将相邻顶点放置到同一分区，以减少边缘切割。在满足容量约束的同时，将一个顶点分配给包含大多数邻居的分区。</span><br></pre></td></tr></table></figure><p>如下图所示，在某个分区中存在1号和4号结点，我们现在要判断2号节点所在分区，根据LDG我们会选择2号结点邻居最多的分区，所以最后会将1，2，4三个结点放在同一个分区。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/11.png" alt="Linear Deterministic Greedy (LDG)"></p><p>不过这样会存在问题，就是所有的结点可能都会在同一个区里。（比如说放置了第一个结点，第二个是它的邻居会放在一起，之后也是如此）<br><img src="/2019/07/25/Streaming-Graph-Partitioning/12.png" alt="聚集到一个分区"></p><p>为了解决这个问题，我们会给每个分区里的结点数量进行限制，其中C就是最大的容量，根据结点个数以及分区的个数计算出来。所以这种方法需要知道图的全局信息，比如结点数量。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/13.png" alt="容量的限制"></p><ul><li><strong>Edge Partitioning Methods(按边的分区方法)</strong><br>这种方法就是判断每条边，应该属于哪一个分区里面，过程如下图。<br>上面的表格就是输入流，（3，2）表示从结点3指向结点2的边。按照箭头顺序输入，这里是随机输入。黄色结点是复制的结点。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/14.png" alt="Edge Partitioning Methods"></li></ul><p>显然对于按边分区的方法来说，复制结点越多，就代表着这种分区是不好的，所以我们在进行按边分区的时候，应该尽可能的减少结点的复制，于是解决的办法就是首先复制那些度高的结点，比如说图中红色的结点，这样能减少总体的复制次数。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/15.png" alt="HDRF"><br>那具体的过程是怎样的呢？首先我们输入边，并且边上的结点都不属于任何分区，如图所示，这里有三个分区，用三种颜射表示。在这种情况下，我们会将这条边放在负载最低的分区里，也就是边最少的分区里。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/16.png" alt="结点不属于任何分区"><br>如果输入的边其中一个结点属于某个分区，另一个不属于任何分区的话，就将这条边放置在结点属于的那个分区里面，也就是下图中蓝色的区。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/17.png" alt="其中一个结点属于某个区"><br>两个结点，其中一个属于多个分区，另一个也属于某个分区，并且有交集，那这条边就会放在有交集的区里，也就是下图橙色的区。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/18.png" alt="结点所在区有交集"><br>如果这两个存在属于不同的分区，却没有交集，根据HDRF也就是先复制度高的，所以我们会复制下图中左边的结点。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/19.png" alt="结点所在区无交集"><br>结果如下<br><img src="/2019/07/25/Streaming-Graph-Partitioning/20.png" alt="根据HDRF分区结果"></p><ul><li><strong>Model-Agnostic (其他方法，混合各种方法使用)</strong><br>其他方法里面也有许多种，这里介绍一下哈希的方法。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/21.png" alt="基于哈希的混合划分"><br>对于低度数的点，我们会对本身结点进行哈希，比如这里的4号结点，我们会对4进行哈希运算，然后将4号结点，以及所有的入边都分配到这个块中。 对于高度数的顶点，我们会对源节点进行哈希，比如这里的1号结点，我们会对2号和5号结点进行哈希，然后按照2号和5号的结果，分配到块中。 这种方法需要知道图的全局信息，还要知道机器数，比如这里的机器数是三，那么求哈希值的时候，就是除以3求余数。 这种方法是边分区和结点分区一起使用的，混合方法。<br>高度顶点和低度顶点的区别是用给定的阈值来区分的，并且首先要确定好分区数量。<h4 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a><strong>Experiment</strong></h4>这个实验中，我们设置的分区数是4<br>分区性能就是指每秒钟的吞吐量，意思就是指每秒钟把多少结点或者边，分配到某一个区里面去。<br>我们的结果表明Hash分区在吞吐量方面优于所有其他评估方法。 然而，性能的差异并不显着。 在这两个实验中，Hash显示的吞吐量最多比第二个最佳分区方法高2倍，并且随着图的增大，这个差异也在减小。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/22.png" alt="Partitioning Performance"></li></ul><p>这里将Twitter和Friendster的分区数设置为16，剩下两个较小的分区数设置为4.<br>A good partitioning method is not only fast but also pro-duces high-quality partitions（不仅要分的快，还要分的好）所以要评判分区的质量。对于按结点的分区来说，我们用edge-cut指标来评判分区的质量，edge-cut越多，说明分区质量就不太高，因为通信成本大大增加了。入就是这个指标对于按边分区的方法来说，我们用结点的复制次数来评判分区的质量，如果复制的次数太多，说明分区的质量不太好。图b就是这个指标。在最后，我们还要考虑负载均衡的问题，也就是分布的较为平均的意思，不能所有的结点或者边，都在一个区里面。哈希的负载均衡是最好的，因为是完全随机的分配的。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/23.png" alt="Partitioning Quality"></p><p>算法的性能也和输入的结点或者边的顺序有关，比如这里是使用随机输入，或者DFS输入，都对算法性能有着很大的影响。<br><img src="/2019/07/25/Streaming-Graph-Partitioning/24.png" alt="Sensitivity to Order"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;论文阅读：Streaming-Graph-Partitioning-An-Experimental-Study&quot;&gt;&lt;a href=&quot;#论文阅读：Streaming-Graph-Partitioning-An-Experimental-Study&quot; class=&quot;h
      
    
    </summary>
    
      <category term="论文阅读" scheme="http://bowiee.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="论文" scheme="http://bowiee.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>MySQL WorkBench 如何运行sql文件，将其变为数据库</title>
    <link href="http://bowiee.github.io/2019/07/25/MySQL-WorkBench/"/>
    <id>http://bowiee.github.io/2019/07/25/MySQL-WorkBench/</id>
    <published>2019-07-25T08:33:08.000Z</published>
    <updated>2019-07-26T06:41:31.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-WorkBench-如何运行sql文件，将其变为数据库"><a href="#MySQL-WorkBench-如何运行sql文件，将其变为数据库" class="headerlink" title="MySQL WorkBench 如何运行sql文件，将其变为数据库"></a>MySQL WorkBench 如何运行sql文件，将其变为数据库</h2><blockquote><p>环境：win10<br>软件：mysql community 5.7.17.0<br>操作时间：2019/7/1</p></blockquote><p>在sql文件里，已经有了生成数据库的语句，这样执行才会生成数据库。<br><strong>下面是操作步骤</strong>：<br><strong>1.打开WorkBench进入操作界面</strong><br><img src="/2019/07/25/MySQL-WorkBench/01.png" alt="进入界面"></p><p>会看到如下图：<br><img src="/2019/07/25/MySQL-WorkBench/02.png" alt="创建数据库界面"></p><p><strong>2.运行sql文件</strong><br>找到运行sql脚本处：<br><img src="/2019/07/25/MySQL-WorkBench/03.png" alt="运行sql文件"></p><p>选取sql文件：<br><img src="/2019/07/25/MySQL-WorkBench/04.png" alt="选取sql文件"></p><p><strong>3.生成数据库</strong><br>最后生成的数据库会显示在图中圈出来部分：<br><img src="/2019/07/25/MySQL-WorkBench/05.png" alt="生成结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-WorkBench-如何运行sql文件，将其变为数据库&quot;&gt;&lt;a href=&quot;#MySQL-WorkBench-如何运行sql文件，将其变为数据库&quot; class=&quot;headerlink&quot; title=&quot;MySQL WorkBench 如何运行sql文件，
      
    
    </summary>
    
      <category term="踩过的坑" scheme="http://bowiee.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="mysql" scheme="http://bowiee.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java JDBC编程流程步骤</title>
    <link href="http://bowiee.github.io/2019/07/25/JDBC/"/>
    <id>http://bowiee.github.io/2019/07/25/JDBC/</id>
    <published>2019-07-25T07:07:48.000Z</published>
    <updated>2019-07-25T07:11:56.233Z</updated>
    
    <content type="html"><![CDATA[<p>JDBC：Java Data Base ConnectionJDBC是用于运行sql语句并从数据库中获取新新的java API.JDBC是用来（让我们的程序）通过网络来操作数据库的，作用非常重要；JDBC技术也是Java核心技术之中的一个。是使用JDBC驱动程序訪问数据库的首选方式<br>JDBC总共分为6步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、注冊驱动 </span><br><span class="line">2、建立连接　</span><br><span class="line">3、创建运行SQL的语句</span><br><span class="line">4、运行语句　　</span><br><span class="line">5、处理运行结果</span><br><span class="line">6、释放资源</span><br></pre></td></tr></table></figure><p>第一步：注册驱动<br>推荐使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(“com.mysql.jdbc.Driver”);</span><br></pre></td></tr></table></figure><p>如果mysql版本高，需要写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(“com.mysql.cj.jdbc.Driver”);</span><br></pre></td></tr></table></figure><p>第二步：建立连接<br>通过Connection建立连接，Connection是一个接口类。其功能是与数据库进行连接。<br>使用方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　Connection con =DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure><p>其中user，password就是数据库的用户名和密码，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/web01</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure><p>第三步：创建运行对象<br>由Statement运行sql语句，不过我们一般使用派生出的PreparedStatement。<br>PreparedStatement能够对SQL语句进行预编译，提高了安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement  ps=connection.prepareStatement( &quot;update user set id=? where username=?”);</span><br></pre></td></tr></table></figure><p>sql中由?表示占位符，再通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps.setObject(1, object);</span><br></pre></td></tr></table></figure><p>来设置值，1就表示第一个问号，也就是id ，Object就是我们要设置的值。<br>第四步：运行sql语句<br>reparedStatement 提供两个经常使用的方法来运行SQL语句。　　<br>executeQuery(Stringsql),该方法用于运行实现查询功能的sql语句。返回类型为ResultSet（结果集）。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet  rs =st.executeQuery(sql);</span><br></pre></td></tr></table></figure><p>executeUpdate(Stringsql),该方法用于运行实现增、删、改功能的sql语句，返回类型为int，即受影响的行数。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int flag = st.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>第五步：处理运行结果</p><p>ResultSet对象　　ResultSet对象负责保存Statement运行后所产生的查询结果。<br>例如我们可以打印出里面的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(rs.getInt(&quot;id&quot;)+&quot;,&quot;+rs.getString(&quot;username&quot;)+&quot;,&quot;+rs.getString(&quot;password&quot;));</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><p>rs就是ResultSet。<br>第六步：<br>数据库资源不关闭，其占用的内存不会被释放，所以要进行关闭。要按照和打开相反的顺序，先打开的后关闭，后打开的先关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">打开</span><br><span class="line">Connection con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">PreparedStatement pstmt = con.prepareStatement(sql);</span><br><span class="line"> ResultSet rs = pstmt.executeQuery();</span><br><span class="line">关闭</span><br><span class="line">rs.close();</span><br><span class="line">pstmt.close();</span><br><span class="line">con.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JDBC：Java Data Base ConnectionJDBC是用于运行sql语句并从数据库中获取新新的java API.JDBC是用来（让我们的程序）通过网络来操作数据库的，作用非常重要；JDBC技术也是Java核心技术之中的一个。是使用JDBC驱动程序訪问数据库的
      
    
    </summary>
    
      <category term="知识总结" scheme="http://bowiee.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://bowiee.github.io/tags/java/"/>
    
      <category term="mysql" scheme="http://bowiee.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
